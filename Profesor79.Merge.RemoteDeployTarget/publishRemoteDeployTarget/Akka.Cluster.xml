<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Akka.Cluster</name>
    </assembly>
    <members>
        <member name="T:Akka.Cluster.AutoDown">
            <summary>
            INTERNAL API
            
            An unreachable member will be downed by this actor if it remains unreachable
            for the specified duration and this actor is running on the leader node in the
            cluster.
            
            The implementation is split into two classes AutoDown and AutoDownBase to be
            able to unit test the logic without running cluster.
            </summary>
        </member>
        <member name="M:Akka.Cluster.AutoDown.Props(System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="autoDownUnreachableAfter">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.AutoDown.UnreachableTimeout">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.AutoDown.UnreachableTimeout.Node">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.AutoDown.UnreachableTimeout.#ctor(Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="node">TBD</param>
        </member>
        <member name="M:Akka.Cluster.AutoDown.#ctor(System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="autoDownUnreachableAfter">TBD</param>
        </member>
        <member name="P:Akka.Cluster.AutoDown.SelfAddress">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.AutoDown.Scheduler">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.AutoDown.PreStart">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.AutoDown.PostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.AutoDown.Down(Akka.Actor.Address)">
            <summary>
            TBD
            </summary>
            <param name="node">TBD</param>
            <exception cref="T:System.InvalidOperationException">TBD</exception>
        </member>
        <member name="T:Akka.Cluster.AutoDownBase">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Cluster.AutoDownBase._leader">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.AutoDownBase.#ctor(System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="autoDownUnreachableAfter">TBD</param>
        </member>
        <member name="M:Akka.Cluster.AutoDownBase.PostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.AutoDownBase.SelfAddress">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.AutoDownBase.Scheduler">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.AutoDownBase.Down(Akka.Actor.Address)">
            <summary>
            TBD
            </summary>
            <param name="node">TBD</param>
        </member>
        <member name="M:Akka.Cluster.AutoDownBase.OnReceive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
        </member>
        <member name="T:Akka.Cluster.AutoDowning">
            <summary>
            Used when no custom provider is configured and 'auto-down-unreachable-after' is enabled.
            </summary>
        </member>
        <member name="M:Akka.Cluster.AutoDowning.#ctor(Akka.Actor.ActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
        </member>
        <member name="P:Akka.Cluster.AutoDowning.DownRemovalMargin">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.AutoDowning.DowningActorProps">
            <summary>
            TBD
            </summary>
            <exception cref="T:Akka.Configuration.ConfigurationException">TBD</exception>
        </member>
        <member name="T:Akka.Cluster.ClusterExtension">
            <summary>
            This class represents an <see cref="T:Akka.Actor.ActorSystem"/> provider used to create the cluster extension.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterExtension.CreateExtension(Akka.Actor.ExtendedActorSystem)">
            <summary>
            Creates the cluster extension using a given actor system.
            </summary>
            <param name="system">The actor system to use when creating the extension.</param>
            <returns>The extension created using the given actor system.</returns>
        </member>
        <member name="T:Akka.Cluster.Cluster">
            <summary>
            <para>
            This class represents an <see cref="T:Akka.Actor.ActorSystem"/> extension used to create, monitor and manage
            a cluster of member nodes hosted within the actor system.
            </para>
            <para>
            Each cluster <see cref="T:Akka.Cluster.Member"/> is identified by its <see cref="T:Akka.Actor.Address"/>
            and the cluster address of this actor system is <see cref="P:Akka.Cluster.Cluster.SelfAddress"/>. A member also has a
            <see cref="T:Akka.Cluster.MemberStatus">status</see>; initially <see cref="F:Akka.Cluster.MemberStatus.Joining"/>
            followed by <see cref="F:Akka.Cluster.MemberStatus.Up"/>.
            </para>
            </summary>
        </member>
        <member name="M:Akka.Cluster.Cluster.Get(Akka.Actor.ActorSystem)">
            <summary>
            Retrieves the extension from the specified actor system.
            </summary>
            <param name="system">The actor system from which to retrieve the extension.</param>
            <returns>The extension retrieved from the given actor system.</returns>
        </member>
        <member name="P:Akka.Cluster.Cluster.IsAssertInvariantsEnabled">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.Cluster.Settings">
            <summary>
            The settings for the cluster.
            </summary>
        </member>
        <member name="P:Akka.Cluster.Cluster.SelfUniqueAddress">
            <summary>
            The current unique address for the cluster, which includes the UID.
            </summary>
        </member>
        <member name="M:Akka.Cluster.Cluster.#ctor(Akka.Actor.Internal.ActorSystemImpl)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Cluster.Cluster"/> class.
            </summary>
            <param name="system">The actor system that hosts the cluster.</param>
            <exception cref="T:Akka.Configuration.ConfigurationException">
            This exception is thrown if the <paramref name="system"/> does not have a <see cref="T:Akka.Cluster.ClusterActorRefProvider"/> enabled in the configuration.
            </exception>
        </member>
        <member name="M:Akka.Cluster.Cluster.Subscribe(Akka.Actor.IActorRef,System.Type[])">
            <summary>
            Subscribe to one or more cluster domain events.
            </summary>
            <param name="subscriber">The actor who'll receive the cluster domain events</param>
            <param name="to"><see cref="T:Akka.Cluster.ClusterEvent.IClusterDomainEvent"/> subclasses</param>
            <remarks>A snapshot of <see cref="T:Akka.Cluster.ClusterEvent.CurrentClusterState"/> will be sent to <paramref name="subscriber"/> as the first message</remarks>
        </member>
        <member name="M:Akka.Cluster.Cluster.Subscribe(Akka.Actor.IActorRef,Akka.Cluster.ClusterEvent.SubscriptionInitialStateMode,System.Type[])">
            <summary>
            Subscribe to one or more cluster domain events.
            </summary>
            <param name="subscriber">The actor who'll receive the cluster domain events</param>
            <param name="initialStateMode">
            If set to <see cref="F:Akka.Cluster.ClusterEvent.SubscriptionInitialStateMode.InitialStateAsEvents"/>, then the events corresponding to the current state
            are sent to <paramref name="subscriber"/> to mimic what it would have seen if it were listening to the events when they occurred in the past.
            
            If set to <see cref="F:Akka.Cluster.ClusterEvent.SubscriptionInitialStateMode.InitialStateAsSnapshot"/>, then a snapshot of
            <see cref="T:Akka.Cluster.ClusterEvent.CurrentClusterState"/> will be sent to <paramref name="subscriber"/> as the first message.
            </param>
            <param name="to">An array of event types that the actor receives.</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the array of supplied types, <paramref name="to"/>, is empty
            or contains types that do not implement <see cref="T:Akka.Cluster.ClusterEvent.IClusterDomainEvent"/>.
            </exception>
        </member>
        <member name="M:Akka.Cluster.Cluster.Unsubscribe(Akka.Actor.IActorRef)">
            <summary>
            Stops the specific actor from receiving all types of cluster domain events.
            </summary>
            <param name="subscriber">The actor that no longer receives cluster domain events.</param>
        </member>
        <member name="M:Akka.Cluster.Cluster.Unsubscribe(Akka.Actor.IActorRef,System.Type)">
            <summary>
            Stops the specific actor from receiving a specific type of cluster domain event.
            </summary>
            <param name="subscriber">The actor that no longer receives cluster domain events.</param>
            <param name="to">The event type that the actor no longer receives.</param>
        </member>
        <member name="M:Akka.Cluster.Cluster.SendCurrentClusterState(Akka.Actor.IActorRef)">
            <summary>
            Sends the current (full) state of the cluster to the specified actor.
            If you want this to happen periodically, you can use the <see cref="P:Akka.Cluster.Cluster.Scheduler"/> to schedule
            a call to this method. You can also call <see cref="P:Akka.Cluster.Cluster.State"/> directly for this information.
            </summary>
            <param name="receiver">The actor that receives the current cluster state.</param>
        </member>
        <member name="M:Akka.Cluster.Cluster.Join(Akka.Actor.Address)">
            <summary>
            Try to join this cluster node specified by <paramref name="address"/>.
            A <see cref="M:Akka.Cluster.Cluster.Join(Akka.Actor.Address)"/> command is sent to the node to join.
            
            An actor system can only join a cluster once. Additional attempts will be ignored.
            When it has successfully joined it must be restarted to be able to join another
            cluster or to join the same cluster again.
            </summary>
            <param name="address">The address of the node we want to join.</param>
        </member>
        <member name="M:Akka.Cluster.Cluster.JoinSeedNodes(System.Collections.Generic.IEnumerable{Akka.Actor.Address})">
            <summary>
            Joins the specified seed nodes without defining them in config.
            Especially useful from tests when Addresses are unknown before startup time.
            
            An actor system can only join a cluster once. Additional attempts will be ignored.
            When it has successfully joined it must be restarted to be able to join another
            cluster or to join the same cluster again.
            </summary>
            <param name="seedNodes">TBD</param>
        </member>
        <member name="M:Akka.Cluster.Cluster.Leave(Akka.Actor.Address)">
            <summary>
            Sends a command to issue state transition to LEAVING for the node specified by <paramref name="address"/>.
            The member will go through the status changes <see cref="F:Akka.Cluster.MemberStatus.Leaving"/> (not published to 
            subscribers) followed by <see cref="F:Akka.Cluster.MemberStatus.Exiting"/> and finally <see cref="F:Akka.Cluster.MemberStatus.Removed"/>.
            
            Note that this command can be issued to any member in the cluster, not necessarily the
            one that is leaving. The cluster extension, but not the actor system, of the leaving member will be shutdown after
            the leader has changed status of the member to <see cref="F:Akka.Cluster.MemberStatus.Exiting"/>. Thereafter the member will be
            removed from the cluster. Normally this is handled automatically, but in case of network failures during
            this process it might still be necessary to set the node's status to <see cref="F:Akka.Cluster.MemberStatus.Down"/> in order
            to complete the removal.
            </summary>
            <param name="address">The address of the node leaving the cluster.</param>
        </member>
        <member name="M:Akka.Cluster.Cluster.LeaveAsync">
            <summary>
            Causes the CURRENT node, i.e. the one calling this function, to leave the cluster.
            
            Once the returned <see cref="T:System.Threading.Tasks.Task"/> completes, it means that the member has successfully been removed
            from the cluster.
            </summary>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> that will return upon the current node being removed from the cluster.</returns>
        </member>
        <member name="M:Akka.Cluster.Cluster.LeaveAsync(System.Threading.CancellationToken)">
            <summary>
            Causes the CURRENT node, i.e. the one calling this function, to leave the cluster.
            
            Once the returned <see cref="T:System.Threading.Tasks.Task"/> completes in completed or cancelled state, it means that the member has successfully been removed
            from the cluster or cancellation token cancelled the task.
            </summary>
            <param name="cancellationToken">The cancellation token to cancel awaiting.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> that will return upon the current node being removed from the cluster, or if await was cancelled.</returns>
            <remarks>
            The cancellation token doesn't cancel leave from the cluster, it only lets to give up on awating (by timeout for example).
            </remarks>
        </member>
        <member name="M:Akka.Cluster.Cluster.Down(Akka.Actor.Address)">
            <summary>
            Sends a command to DOWN the node specified by <paramref name="address"/>.
            
            When a member is considered by the failure detector to be unreachable the leader is not
            allowed to perform its duties, such as changing status of new joining members to <see cref="F:Akka.Cluster.MemberStatus.Up"/>.
            The status of the unreachable member must be changed to <see cref="F:Akka.Cluster.MemberStatus.Down"/>, which can be done with
            this method.
            </summary>
            <param name="address">The address of the node we're going to mark as <see cref="F:Akka.Cluster.MemberStatus.Down"/></param>
        </member>
        <member name="M:Akka.Cluster.Cluster.RegisterOnMemberUp(System.Action)">
            <summary>
            Registers the supplied callback to run once when the current cluster member is <see cref="F:Akka.Cluster.MemberStatus.Up"/>.
            Typically used together with configuration option 'akka.cluster.min-nr-of-members' to defer some action,
            such as starting actors, until the cluster has reached a certain size.
            </summary>
            <param name="callback">The callback that is run whenever the current member achieves a status of <see cref="F:Akka.Cluster.MemberStatus.Up"/></param>
        </member>
        <member name="M:Akka.Cluster.Cluster.RegisterOnMemberRemoved(System.Action)">
            <summary>
            Registers the supplied callback to run once when the current cluster member is <see cref="F:Akka.Cluster.MemberStatus.Removed"/>.
            
            Typically used in combination with <see cref="M:Akka.Cluster.Cluster.Leave(Akka.Actor.Address)"/> and <see cref="M:Akka.Actor.ActorSystem.Terminate"/>.
            </summary>
            <param name="callback">The callback that is run whenever the current member achieves a status of <see cref="F:Akka.Cluster.MemberStatus.Down"/></param>
        </member>
        <member name="M:Akka.Cluster.Cluster.RemotePathOf(Akka.Actor.IActorRef)">
            <summary>
            Generates the remote actor path by replacing the <see cref="P:Akka.Actor.ActorPath.Address"/> in the RootActorPath for the given
            ActorRef with the cluster's <see cref="P:Akka.Cluster.Cluster.SelfAddress"/>, unless address' host is already defined
            </summary>
            <param name="actorRef">An <see cref="T:Akka.Actor.IActorRef"/> belonging to the current node.</param>
            <returns>The absolute remote <see cref="T:Akka.Actor.ActorPath"/> of <see cref="!:actorRef"/>.</returns>
        </member>
        <member name="P:Akka.Cluster.Cluster.SelfAddress">
            <summary>
            The address of this cluster member.
            </summary>
        </member>
        <member name="P:Akka.Cluster.Cluster.SelfRoles">
            <summary>
            The roles that this cluster member is currently a part.
            </summary>
        </member>
        <member name="P:Akka.Cluster.Cluster.State">
            <summary>
            The current snapshot state of the cluster.
            </summary>
        </member>
        <member name="P:Akka.Cluster.Cluster.IsTerminated">
            <summary>
            Determine whether or not this cluster instance has been shutdown.
            </summary>
        </member>
        <member name="P:Akka.Cluster.Cluster.System">
            <summary>
            The underlying <see cref="T:Akka.Actor.ActorSystem"/> supported by this plugin.
            </summary>
        </member>
        <member name="P:Akka.Cluster.Cluster.ReadView">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.Cluster.FailureDetector">
            <summary>
            The set of failure detectors used for monitoring one or more nodes in the cluster.
            </summary>
        </member>
        <member name="P:Akka.Cluster.Cluster.DowningProvider">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.Cluster.Scheduler">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.Cluster.Shutdown">
            <summary>
            INTERNAL API.
            
            Shuts down all connections to other members, the cluster daemon and the periodic gossip and cleanup tasks.
            This should not be called directly by the user
            
            The user can issue a <see cref="M:Akka.Cluster.Cluster.Leave(Akka.Actor.Address)"/> command which will tell the node
            to go through graceful handoff process <c>LEAVE -> EXITING ->  REMOVED -> SHUTDOWN</c>.
            </summary>
        </member>
        <member name="P:Akka.Cluster.Cluster.ClusterCore">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.Cluster.LogInfo(System.String)">
            <summary>
            Creates an <see cref="F:Akka.Event.LogLevel.InfoLevel"/> log entry with the specific message.
            </summary>
            <param name="message">The message being logged.</param>
        </member>
        <member name="M:Akka.Cluster.Cluster.LogInfo(System.String,System.Object)">
            <summary>
            Creates an <see cref="F:Akka.Event.LogLevel.InfoLevel"/> log entry with the specific template and arguments.
            </summary>
            <param name="template">The template being rendered and logged.</param>
            <param name="arg1">The argument that fills in the template placeholder.</param>
        </member>
        <member name="M:Akka.Cluster.Cluster.LogInfo(System.String,System.Object,System.Object)">
            <summary>
            Creates an <see cref="F:Akka.Event.LogLevel.InfoLevel"/> log entry with the specific template and arguments.
            </summary>
            <param name="template">The template being rendered and logged.</param>
            <param name="arg1">The first argument that fills in the cooresponding template placeholder.</param>
            <param name="arg2">The second argument that fills in the cooresponding template placeholder.</param>
        </member>
        <member name="T:Akka.Cluster.ClusterActorRefProvider">
            <summary>
            INTERNAL API
            
            The `ClusterActorRefProvider` will load the <see cref="T:Akka.Cluster.Cluster"/>
            extension, i.e. the cluster will automatically be started when
            the `ClusterActorRefProvider` is used.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterActorRefProvider.#ctor(System.String,Akka.Actor.Settings,Akka.Event.EventStream)">
            <summary>
            TBD
            </summary>
            <param name="systemName">TBD</param>
            <param name="settings">TBD</param>
            <param name="eventStream">TBD</param>
        </member>
        <member name="M:Akka.Cluster.ClusterActorRefProvider.Init(Akka.Actor.Internal.ActorSystemImpl)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
        </member>
        <member name="M:Akka.Cluster.ClusterActorRefProvider.CreateRemoteWatcher(Akka.Actor.Internal.ActorSystemImpl)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.ClusterScope">
            <summary>
            This class represents a binding of an actor deployment to a cluster-aware system.
            </summary>
        </member>
        <member name="F:Akka.Cluster.ClusterScope.Instance">
            <summary>
            The singleton instance of this scope.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterScope.WithFallback(Akka.Actor.Scope)">
             <summary>
             Creates a new <see cref="T:Akka.Actor.Scope" /> from this scope using another <see cref="T:Akka.Actor.Scope" />
             to backfill options that might be missing from this scope.
            
             <note>
             This method ignores the given scope and returns the singleton instance of this scope.
             </note>
             </summary>
             <param name="other">The <see cref="T:Akka.Actor.Scope" /> used for fallback configuration.</param>
             <returns>The singleton instance of this scope</returns>
        </member>
        <member name="M:Akka.Cluster.ClusterScope.Copy">
            <summary>
            Creates a copy of the current instance.
            
            <note>
            This method returns the singleton instance of this scope.
            </note>
            </summary>
            <returns>The singleton instance of this scope</returns>
        </member>
        <member name="T:Akka.Cluster.ClusterDeployer">
            <summary>
            INTERNAL API
            
            Deployer of cluster-aware routers
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterDeployer.#ctor(Akka.Actor.Settings)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Cluster.ClusterDeployer"/> class.
            </summary>
            <param name="settings">The settings used to configure the deployer.</param>
        </member>
        <member name="M:Akka.Cluster.ClusterDeployer.ParseConfig(System.String,Akka.Configuration.Config)">
            <summary>
            Creates an actor deployment to the supplied path, <paramref name="key" />, using the supplied configuration, <paramref name="config" />.
            </summary>
            <param name="key">The path used to deploy the actor.</param>
            <param name="config">The configuration used to configure the deployed actor.</param>
            <returns>A configured actor deployment to the given path.</returns>
            <exception cref="T:Akka.Configuration.ConfigurationException">
            This exception is thrown when the deployment has a scope defined in the configuration
            or the router is configured as a <see cref="T:Akka.Remote.Routing.RemoteRouterConfig"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the router is not configured as either a <see cref="T:Akka.Routing.Pool"/> or a <see cref="T:Akka.Routing.Group"/>.
            </exception>
        </member>
        <member name="T:Akka.Cluster.IClusterMessage">
            <summary>
            Base interface for all cluster messages. All ClusterMessage's are serializable.
            </summary>
        </member>
        <member name="T:Akka.Cluster.ClusterUserAction">
            <summary>
            Cluster commands sent by the USER via <see cref="T:Akka.Cluster.Cluster"/> extension.
            </summary>
        </member>
        <member name="T:Akka.Cluster.ClusterUserAction.BaseClusterUserAction">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterUserAction.BaseClusterUserAction.#ctor(Akka.Actor.Address)">
            <summary>
            TBD
            </summary>
            <param name="address">TBD</param>
        </member>
        <member name="P:Akka.Cluster.ClusterUserAction.BaseClusterUserAction.Address">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterUserAction.BaseClusterUserAction.Equals(Akka.Cluster.ClusterUserAction.BaseClusterUserAction)">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.ClusterUserAction.BaseClusterUserAction.Equals(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.ClusterUserAction.BaseClusterUserAction.GetHashCode">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.ClusterUserAction.JoinTo">
            <summary>
            Command to initiate join another node (represented by `address`).
            Join will be sent to the other node.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterUserAction.JoinTo.#ctor(Akka.Actor.Address)">
            <summary>
            TBD
            </summary>
            <param name="address">TBD</param>
        </member>
        <member name="T:Akka.Cluster.ClusterUserAction.Leave">
            <summary>
            Command to leave the cluster.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterUserAction.Leave.#ctor(Akka.Actor.Address)">
            <summary>
            TBD
            </summary>
            <param name="address">TBD</param>
        </member>
        <member name="T:Akka.Cluster.ClusterUserAction.Down">
            <summary>
            Command to mark node as temporary down.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterUserAction.Down.#ctor(Akka.Actor.Address)">
            <summary>
            TBD
            </summary>
            <param name="address">TBD</param>
        </member>
        <member name="T:Akka.Cluster.InternalClusterAction">
            <summary>
            Command to join the cluster. Sent when a node wants to join another node (the receiver).
            </summary>
        </member>
        <member name="T:Akka.Cluster.InternalClusterAction.Join">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.InternalClusterAction.Join.#ctor(Akka.Cluster.UniqueAddress,System.Collections.Immutable.ImmutableHashSet{System.String})">
            <summary>
            TBD
            </summary>
            <param name="node">the node that wants to join the cluster</param>
            <param name="roles">TBD</param>
        </member>
        <member name="P:Akka.Cluster.InternalClusterAction.Join.Node">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.InternalClusterAction.Join.Roles">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.InternalClusterAction.Join.Equals(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.InternalClusterAction.Join.GetHashCode">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.InternalClusterAction.Join.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.InternalClusterAction.Welcome">
            <summary>
            Reply to Join
            </summary>
        </member>
        <member name="M:Akka.Cluster.InternalClusterAction.Welcome.#ctor(Akka.Cluster.UniqueAddress,Akka.Cluster.Gossip)">
            <summary>
            TBD
            </summary>
            <param name="from">the sender node in the cluster, i.e. the node that received the Join command</param>
            <param name="gossip">TBD</param>
        </member>
        <member name="P:Akka.Cluster.InternalClusterAction.Welcome.From">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.InternalClusterAction.Welcome.Gossip">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.InternalClusterAction.Welcome.Equals(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.InternalClusterAction.Welcome.GetHashCode">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.InternalClusterAction.JoinSeedNodes">
            <summary>
            Command to initiate the process to join the specified
            seed nodes.
            </summary>
        </member>
        <member name="M:Akka.Cluster.InternalClusterAction.JoinSeedNodes.#ctor(System.Collections.Immutable.ImmutableList{Akka.Actor.Address})">
            <summary>
            TBD
            </summary>
            <param name="seedNodes">TBD</param>
        </member>
        <member name="P:Akka.Cluster.InternalClusterAction.JoinSeedNodes.SeedNodes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Cluster.InternalClusterAction.JoinSeenNode">
            <summary>
            Start message of the process to join one of the seed nodes.
            The node sends <see cref="T:Akka.Cluster.InternalClusterAction.InitJoin"/> to all seed nodes, which replies
            with <see cref="T:Akka.Cluster.InternalClusterAction.InitJoinAck"/>. The first reply is used others are discarded.
            The node sends <see cref="T:Akka.Cluster.InternalClusterAction.Join"/> command to the seed node that replied first.
            If a node is uninitialized it will reply to `InitJoin` with
            <see cref="T:Akka.Cluster.InternalClusterAction.InitJoinNack"/>.
            </summary>
        </member>
        <member name="T:Akka.Cluster.InternalClusterAction.InitJoin">
            <inheritdoc cref="T:Akka.Cluster.InternalClusterAction.JoinSeenNode"/>
        </member>
        <member name="M:Akka.Cluster.InternalClusterAction.InitJoin.Equals(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.InternalClusterAction.InitJoinAck">
            <inheritdoc cref="T:Akka.Cluster.InternalClusterAction.JoinSeenNode"/>
        </member>
        <member name="M:Akka.Cluster.InternalClusterAction.InitJoinAck.#ctor(Akka.Actor.Address)">
            <summary>
            TBD
            </summary>
            <param name="address">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Cluster.InternalClusterAction.InitJoinAck.Address">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.InternalClusterAction.InitJoinAck.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Akka.Cluster.InternalClusterAction.InitJoinAck.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="T:Akka.Cluster.InternalClusterAction.InitJoinNack">
            <inheritdoc cref="T:Akka.Cluster.InternalClusterAction.JoinSeenNode"/>
        </member>
        <member name="M:Akka.Cluster.InternalClusterAction.InitJoinNack.#ctor(Akka.Actor.Address)">
            <summary>
            TBD
            </summary>
            <param name="address">The address we attempted to join</param>
        </member>
        <member name="P:Akka.Cluster.InternalClusterAction.InitJoinNack.Address">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.InternalClusterAction.InitJoinNack.Equals(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.InternalClusterAction.InitJoinNack.GetHashCode">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.InternalClusterAction.ExitingConfirmed">
            <summary>
            Signals that a member is confirmed to be exiting the cluster
            </summary>
        </member>
        <member name="P:Akka.Cluster.InternalClusterAction.ExitingConfirmed.Address">
            <summary>
            The member's address
            </summary>
        </member>
        <member name="M:Akka.Cluster.InternalClusterAction.ExitingConfirmed.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Akka.Cluster.InternalClusterAction.ExitingConfirmed.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="T:Akka.Cluster.InternalClusterAction.ExitingCompleted">
            <summary>
            Used to signal that a self-exiting event has completed.
            </summary>
        </member>
        <member name="F:Akka.Cluster.InternalClusterAction.ExitingCompleted.Instance">
            <summary>
            Singleton instance
            </summary>
        </member>
        <member name="T:Akka.Cluster.InternalClusterAction.ITick">
            <summary>
            Marker interface for periodic tick messages
            </summary>
        </member>
        <member name="T:Akka.Cluster.InternalClusterAction.GossipTick">
            <summary>
            Used to trigger the publication of gossip
            </summary>
        </member>
        <member name="P:Akka.Cluster.InternalClusterAction.GossipTick.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Cluster.InternalClusterAction.GossipSpeedupTick">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.InternalClusterAction.GossipSpeedupTick.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Cluster.InternalClusterAction.ReapUnreachableTick">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.InternalClusterAction.ReapUnreachableTick.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Cluster.InternalClusterAction.MetricsTick">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.InternalClusterAction.MetricsTick.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Cluster.InternalClusterAction.LeaderActionsTick">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.InternalClusterAction.LeaderActionsTick.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Cluster.InternalClusterAction.PublishStatsTick">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.InternalClusterAction.PublishStatsTick.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Cluster.InternalClusterAction.SendGossipTo">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.InternalClusterAction.SendGossipTo.#ctor(Akka.Actor.Address)">
            <summary>
            TBD
            </summary>
            <param name="address">TBD</param>
        </member>
        <member name="P:Akka.Cluster.InternalClusterAction.SendGossipTo.Address">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.InternalClusterAction.SendGossipTo.Equals(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.InternalClusterAction.SendGossipTo.GetHashCode">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.InternalClusterAction.GetClusterCoreRef">
            <summary>
            Gets a reference to the cluster core daemon.
            </summary>
        </member>
        <member name="P:Akka.Cluster.InternalClusterAction.GetClusterCoreRef.Instance">
            <summary>
            The singleton instance
            </summary>
        </member>
        <member name="T:Akka.Cluster.InternalClusterAction.AddOnMemberUpListener">
            <summary>
            Command to <see cref="T:Akka.Cluster.ClusterDaemon"/> to create a
            <see cref="T:Akka.Cluster.OnMemberStatusChangedListener"/>
            </summary>
        </member>
        <member name="M:Akka.Cluster.InternalClusterAction.AddOnMemberUpListener.#ctor(System.Action)">
            <summary>
            TBD
            </summary>
            <param name="callback">TBD</param>
        </member>
        <member name="P:Akka.Cluster.InternalClusterAction.AddOnMemberUpListener.Callback">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Cluster.InternalClusterAction.AddOnMemberRemovedListener">
            <summary>
            Command to the <see cref="T:Akka.Cluster.ClusterDaemon"/> to create a 
            </summary>
        </member>
        <member name="M:Akka.Cluster.InternalClusterAction.AddOnMemberRemovedListener.#ctor(System.Action)">
            <summary>
            TBD
            </summary>
            <param name="callback">TBD</param>
        </member>
        <member name="P:Akka.Cluster.InternalClusterAction.AddOnMemberRemovedListener.Callback">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Cluster.InternalClusterAction.ISubscriptionMessage">
            <summary>
            All messages related to creating or removing <see cref="T:Akka.Cluster.Cluster"/> event subscriptions
            </summary>
        </member>
        <member name="T:Akka.Cluster.InternalClusterAction.Subscribe">
            <summary>
            Subscribe an actor to new <see cref="T:Akka.Cluster.Cluster"/> events.
            </summary>
        </member>
        <member name="M:Akka.Cluster.InternalClusterAction.Subscribe.#ctor(Akka.Actor.IActorRef,Akka.Cluster.ClusterEvent.SubscriptionInitialStateMode,System.Collections.Immutable.ImmutableHashSet{System.Type})">
            <summary>
            Creates a new subscription
            </summary>
            <param name="subscriber">The actor being subscribed to events.</param>
            <param name="initialStateMode">The initial state of the subscription.</param>
            <param name="to">The range of event types to which we'll be subscribing.</param>
        </member>
        <member name="P:Akka.Cluster.InternalClusterAction.Subscribe.Subscriber">
            <summary>
            The subcriber
            </summary>
        </member>
        <member name="P:Akka.Cluster.InternalClusterAction.Subscribe.InitialStateMode">
            <summary>
            The delivery mechanism for the initial cluster state.
            </summary>
        </member>
        <member name="P:Akka.Cluster.InternalClusterAction.Subscribe.To">
            <summary>
            The range of cluster events to which <see cref="P:Akka.Cluster.InternalClusterAction.Subscribe.Subscriber"/> is subscribed.
            </summary>
        </member>
        <member name="T:Akka.Cluster.InternalClusterAction.Unsubscribe">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.InternalClusterAction.Unsubscribe.#ctor(Akka.Actor.IActorRef,System.Type)">
            <summary>
            TBD
            </summary>
            <param name="subscriber">TBD</param>
            <param name="to">TBD</param>
        </member>
        <member name="P:Akka.Cluster.InternalClusterAction.Unsubscribe.Subscriber">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.InternalClusterAction.Unsubscribe.To">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Cluster.InternalClusterAction.SendCurrentClusterState">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.InternalClusterAction.SendCurrentClusterState.Receiver">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.InternalClusterAction.SendCurrentClusterState.#ctor(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="receiver"><see cref="T:Akka.Cluster.ClusterEvent.CurrentClusterState"/> will be sent to the `receiver`</param>
        </member>
        <member name="T:Akka.Cluster.InternalClusterAction.IPublishMessage">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Cluster.InternalClusterAction.PublishChanges">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.InternalClusterAction.PublishChanges.#ctor(Akka.Cluster.Gossip)">
            <summary>
            TBD
            </summary>
            <param name="newGossip">TBD</param>
        </member>
        <member name="P:Akka.Cluster.InternalClusterAction.PublishChanges.NewGossip">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Cluster.InternalClusterAction.PublishEvent">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.InternalClusterAction.PublishEvent.#ctor(Akka.Cluster.ClusterEvent.IClusterDomainEvent)">
            <summary>
            TBD
            </summary>
            <param name="event">TBD</param>
        </member>
        <member name="P:Akka.Cluster.InternalClusterAction.PublishEvent.Event">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Cluster.ClusterDaemon">
            <summary>
            Supervisor managing the different Cluster daemons.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterDaemon.#ctor(Akka.Cluster.ClusterSettings)">
            <summary>
            Creates a new instance of the ClusterDaemon
            </summary>
            <param name="settings">The settings that will be used for the <see cref="T:Akka.Cluster.Cluster"/>.</param>
        </member>
        <member name="T:Akka.Cluster.ClusterCoreSupervisor">
            <summary>
            ClusterCoreDaemon and ClusterDomainEventPublisher can't be restarted because the state
            would be obsolete. Shutdown the member if any those actors crashed.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreSupervisor.#ctor">
            <summary>
            Creates a new instance of the ClusterCoreSupervisor
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreSupervisor.SupervisorStrategy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreSupervisor.PostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Cluster.ClusterCoreDaemon">
            <summary>
            INTERNAL API
            
            Actor used to power the guts of the Akka.Cluster membership and gossip protocols.
            </summary>
        </member>
        <member name="F:Akka.Cluster.ClusterCoreDaemon.SelfUniqueAddress">
            <summary>
            The current self-unique address.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.#ctor(Akka.Actor.IActorRef)">
            <summary>
            Creates a new cluster core daemon instance.
            </summary>
            <param name="publisher">A reference to the <see cref="T:Akka.Cluster.ClusterDomainEventPublisher"/>.</param>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.PreStart">
            <inheritdoc cref="M:Akka.Actor.ActorBase.PreStart"/>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.PostStop">
            <inheritdoc cref="M:Akka.Actor.ActorBase.PostStop"/>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.OnReceive(System.Object)">
            <inheritdoc cref="M:Akka.Actor.ActorBase.PreStart"/>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.Unhandled(System.Object)">
            <inheritdoc cref="M:Akka.Actor.ActorBase.Unhandled(System.Object)"/>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.InitJoin">
            <summary>
            Begins the joining process.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.JoinSeedNodes(System.Collections.Immutable.ImmutableList{Akka.Actor.Address})">
            <summary>
            Attempts to join this node or one or more seed nodes.
            </summary>
            <param name="newSeedNodes">The list of seed nod we're attempting to join.</param>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.Join(Akka.Actor.Address)">
            <summary>
            Try to join this cluster node with the node specified by `address`.
            It's only allowed to join from an empty state, i.e. when not already a member.
            A `Join(selfUniqueAddress)` command is sent to the node to join,
            which will reply with a `Welcome` message.
            </summary>
            <param name="address">The address of the node we're going to join.</param>
            <exception cref="T:System.InvalidOperationException">Join can only be done from an empty state</exception>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.StopSeedNodeProcess">
            <summary>
            Stops the seed node process after the cluster has started.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.Joining(Akka.Cluster.UniqueAddress,System.Collections.Immutable.ImmutableHashSet{System.String})">
            <summary>
            State transition to JOINING - new node joining.
            Received `Join` message and replies with `Welcome` message, containing
            current gossip state, including the new joining member.
            </summary>
            <param name="node">TBD</param>
            <param name="roles">TBD</param>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.Welcome(Akka.Actor.Address,Akka.Cluster.UniqueAddress,Akka.Cluster.Gossip)">
            <summary>
            Reply from Join request
            </summary>
            <param name="joinWith">TBD</param>
            <param name="from">TBD</param>
            <param name="gossip">TBD</param>
            <exception cref="T:System.InvalidOperationException">Welcome can only be done from an empty state</exception>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.Leaving(Akka.Actor.Address)">
            <summary>
            State transition to LEAVING.
            The node will eventually be removed by the leader, after hand-off in EXITING, and only after
            removal a new node with same address can join the cluster through the normal joining procedure.
            </summary>
            <param name="address">The address.</param>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.Shutdown">
            <summary>
            This method is called when a member sees itself as Exiting or Down.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.Downing(Akka.Actor.Address)">
            <summary>
            State transition to DOWN.
            Its status is set to DOWN.The node is also removed from the `seen` table.
            The node will eventually be removed by the leader, and only after removal a new node with same address can
            join the cluster through the normal joining procedure.
            </summary>
            <param name="address">The address of the member that will be downed.</param>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.Quarantined(Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="node">TBD</param>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.ReceiveGossipStatus(Akka.Cluster.GossipStatus)">
            <summary>
            TBD
            </summary>
            <param name="status">TBD</param>
        </member>
        <member name="T:Akka.Cluster.ClusterCoreDaemon.ReceiveGossipType">
            <summary>
            The types of gossip actions that receive gossip has performed.
            </summary>
        </member>
        <member name="F:Akka.Cluster.ClusterCoreDaemon.ReceiveGossipType.Ignored">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Cluster.ClusterCoreDaemon.ReceiveGossipType.Older">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Cluster.ClusterCoreDaemon.ReceiveGossipType.Newer">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Cluster.ClusterCoreDaemon.ReceiveGossipType.Same">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Cluster.ClusterCoreDaemon.ReceiveGossipType.Merge">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.ReceiveGossip(Akka.Cluster.GossipEnvelope)">
            <summary>
            The types of gossip actions that receive gossip has performed.
            </summary>
            <param name="envelope">The gossip payload.</param>
            <returns>A command indicating how the gossip should be handled.</returns>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.GossipTick">
            <summary>
            Sends gossip and schedules two future intervals for more gossip
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.GossipSpeedupTick">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.IsGossipSpeedupNeeded">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.SendGossipRandom(System.Int32)">
            <summary>
            Sends full gossip to `n` other random members.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.SendGossip">
            <summary>
            Initiates a new round of gossip.
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterCoreDaemon.AdjustedGossipDifferentViewProbability">
            <summary>
            For large clusters we should avoid shooting down individual
            nodes. Therefore the probability is reduced for large clusters
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.LeaderActions">
            <summary>
            Runs periodic leader actions, such as member status transitions, assigning partitions etc.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.IsMinNrOfMembersFulfilled">
            <summary>
            If akka.cluster.min-rn-of-members or akka.cluster.roles.[rolename].min-nr-of-members is set,
            this function will check to see if that threshold is met.
            </summary>
            <returns>
            <c>true</c> if the setting isn't enabled or is satisfied. 
            <c>false</c> is the setting is enabled and unsatisfied.
            </returns>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.LeaderActionsOnConvergence">
            <summary>
            Leader actions are as follows:
            1. Move JOINING     => UP                   -- When a node joins the cluster
            2. Move LEAVING     => EXITING              -- When all partition handoff has completed
            3. Non-exiting remain                       -- When all partition handoff has completed
            4. Move unreachable EXITING => REMOVED      -- When all nodes have seen the EXITING node as unreachable (convergence) -
                                                            remove the node from the node ring and seen table
            5. Move unreachable DOWN/EXITING => REMOVED -- When all nodes have seen that the node is DOWN/EXITING (convergence) -
                                                            remove the node from the node ring and seen table
            7. Updating the vclock version for the changes
            8. Updating the `seen` table
            9. Update the state with the new gossip
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.ReapUnreachableMembers">
            <summary>
            Reaps the unreachable members according to the failure detector's verdict.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.SelectRandomNode(System.Collections.Immutable.ImmutableList{Akka.Cluster.UniqueAddress})">
            <summary>
            TBD
            </summary>
            <param name="nodes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Cluster.ClusterCoreDaemon.IsSingletonCluster">
            <summary>
            Returns <c>true</c> if this is a one node cluster. <c>false</c> otherwise.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.SendGossipTo(Akka.Actor.Address)">
            <summary>
            needed for tests
            </summary>
            <param name="address">TBD</param>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.GossipTo(Akka.Cluster.UniqueAddress)">
            <summary>
            Gossips latest gossip to a node.
            </summary>
            <param name="node">The address of the node we want to send gossip to.</param>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.GossipTo(Akka.Cluster.UniqueAddress,Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="node">TBD</param>
            <param name="destination">TBD</param>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.GossipStatusTo(Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="node">TBD</param>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.GossipStatusTo(Akka.Cluster.UniqueAddress,Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="node">TBD</param>
            <param name="destination">TBD</param>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.ValidNodeForGossip(Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="node">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.UpdateLatestGossip(Akka.Cluster.Gossip)">
            <summary>
            Updates the local gossip with the latest received from over the network.
            </summary>
            <param name="newGossip">The new gossip to merge with our own.</param>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.AssertLatestGossip">
            <summary>
            TBD
            </summary>
            <exception cref="T:System.InvalidOperationException">TBD</exception>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.Publish(Akka.Cluster.Gossip)">
            <summary>
            Publishes gossip to other nodes in the cluster.
            </summary>
            <param name="newGossip">The new gossip to share.</param>
        </member>
        <member name="M:Akka.Cluster.ClusterCoreDaemon.PublishInternalStats">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Cluster.JoinSeedNodeProcess">
            <summary>
            INTERNAL API
            
            Sends <see cref="T:Akka.Cluster.InternalClusterAction.InitJoin"/> to all seed nodes (except itself) and expect
            <see cref="T:Akka.Cluster.InternalClusterAction.InitJoinAck"/> reply back. The seed node that replied first
            will be used and joined to. <see cref="T:Akka.Cluster.InternalClusterAction.InitJoinAck"/> replies received after
            the first one are ignored.
            
            Retries if no <see cref="T:Akka.Cluster.InternalClusterAction.InitJoinAck"/> replies are received within the 
            <see cref="P:Akka.Cluster.ClusterSettings.SeedNodeTimeout"/>. When at least one reply has been received it stops itself after
            an idle <see cref="P:Akka.Cluster.ClusterSettings.SeedNodeTimeout"/>.
            
            The seed nodes can be started in any order, but they will not be "active" until they have been
            able to join another seed node (seed1.)
            
            They will retry the join procedure.
            
            Possible scenarios:
             1. seed2 started, but doesn't get any ack from seed1 or seed3
             2. seed3 started, doesn't get any ack from seed1 or seed3 (seed2 doesn't reply)
             3. seed1 is started and joins itself
             4. seed2 retries the join procedure and gets an ack from seed1, and then joins to seed1
             5. seed3 retries the join procedure and gets acks from seed2 first, and then joins to seed2
            </summary>
        </member>
        <member name="M:Akka.Cluster.JoinSeedNodeProcess.#ctor(System.Collections.Immutable.ImmutableList{Akka.Actor.Address})">
            <summary>
            TBD
            </summary>
            <param name="seeds">TBD</param>
        </member>
        <member name="M:Akka.Cluster.JoinSeedNodeProcess.PreStart">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.JoinSeedNodeProcess.OnReceive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
        </member>
        <member name="T:Akka.Cluster.FirstSeedNodeProcess">
            <summary>
            INTERNAL API
            
            Used only for the first seed node.
            Sends <see cref="T:Akka.Cluster.InternalClusterAction.InitJoin"/> to all seed nodes except itself.
            If other seed nodes are not part of the cluster yet they will reply with 
            <see cref="T:Akka.Cluster.InternalClusterAction.InitJoinNack"/> or not respond at all and then the
            first seed node will join itself to initialize the new cluster. When the first seed 
            node is restarted, and some other seed node is part of the cluster it will reply with
            <see cref="T:Akka.Cluster.InternalClusterAction.InitJoinAck"/> and then the first seed node will
            join that other seed node to join the existing cluster.
            </summary>
        </member>
        <member name="M:Akka.Cluster.FirstSeedNodeProcess.#ctor(System.Collections.Immutable.ImmutableList{Akka.Actor.Address})">
            <summary>
            TBD
            </summary>
            <param name="seeds">TBD</param>
        </member>
        <member name="M:Akka.Cluster.FirstSeedNodeProcess.PostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.FirstSeedNodeProcess.OnReceive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
        </member>
        <member name="T:Akka.Cluster.GossipStats">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="F:Akka.Cluster.GossipStats.ReceivedGossipCount">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Cluster.GossipStats.MergeCount">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Cluster.GossipStats.SameCount">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Cluster.GossipStats.NewerCount">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Cluster.GossipStats.OlderCount">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.GossipStats.#ctor(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            TBD
            </summary>
            <param name="receivedGossipCount">TBD</param>
            <param name="mergeCount">TBD</param>
            <param name="sameCount">TBD</param>
            <param name="newerCount">TBD</param>
            <param name="olderCount">TBD</param>
        </member>
        <member name="M:Akka.Cluster.GossipStats.IncrementMergeCount">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.GossipStats.IncrementSameCount">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.GossipStats.IncrementNewerCount">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.GossipStats.IncrementOlderCount">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.GossipStats.Copy(System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64})">
            <summary>
            TBD
            </summary>
            <param name="receivedGossipCount">TBD</param>
            <param name="mergeCount">TBD</param>
            <param name="sameCount">TBD</param>
            <param name="newerCount">TBD</param>
            <param name="olderCount">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.GossipStats.op_Addition(Akka.Cluster.GossipStats,Akka.Cluster.GossipStats)">
            <summary>
            TBD
            </summary>
            <param name="a">TBD</param>
            <param name="b">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.GossipStats.op_Subtraction(Akka.Cluster.GossipStats,Akka.Cluster.GossipStats)">
            <summary>
            TBD
            </summary>
            <param name="a">TBD</param>
            <param name="b">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.OnMemberStatusChangedListener">
            <summary>
            INTERNAL API
            
            The supplied callback will be run once when the current cluster member has the same status.
            </summary>
        </member>
        <member name="M:Akka.Cluster.OnMemberStatusChangedListener.#ctor(System.Action,Akka.Cluster.MemberStatus)">
            <summary>
            TBD
            </summary>
            <param name="callback">TBD</param>
            <param name="targetStatus">TBD</param>
        </member>
        <member name="M:Akka.Cluster.OnMemberStatusChangedListener.PreStart">
            <inheritdoc cref="M:Akka.Actor.ActorBase.PreStart"/>
        </member>
        <member name="M:Akka.Cluster.OnMemberStatusChangedListener.PostStop">
            <inheritdoc cref="M:Akka.Actor.ActorBase.PostStop"/>
        </member>
        <member name="T:Akka.Cluster.VectorClockStats">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.VectorClockStats.#ctor(System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="versionSize">TBD</param>
            <param name="seenLatest">TBD</param>
        </member>
        <member name="P:Akka.Cluster.VectorClockStats.VersionSize">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.VectorClockStats.SeenLatest">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.VectorClockStats.Equals(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.VectorClockStats.GetHashCode">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.ClusterEvent">
            <summary>
            Domain events published to the event bus.
            Subscribe with:
            <code>
            var cluster = new Cluster(system);
            cluster.Subscribe(actorRef, typeof(IClusterDomainEvent));
            </code>
            </summary>
        </member>
        <member name="T:Akka.Cluster.ClusterEvent.SubscriptionInitialStateMode">
            <summary>
            The mode for getting the current state of the cluster upon first subscribing.
            </summary>
        </member>
        <member name="F:Akka.Cluster.ClusterEvent.SubscriptionInitialStateMode.InitialStateAsSnapshot">
            <summary>
            When using this subscription mode a snapshot of
            <see cref="T:Akka.Cluster.ClusterEvent.CurrentClusterState"/> will be sent to the
            subscriber as the first message.
            </summary>
        </member>
        <member name="F:Akka.Cluster.ClusterEvent.SubscriptionInitialStateMode.InitialStateAsEvents">
            <summary>
            When using this subscription mode the events corresponding
            to the current state will be sent to the subscriber to mimic what you would
            have seen if you were listening to the events when they occurred in the past.
            </summary>
        </member>
        <member name="F:Akka.Cluster.ClusterEvent.InitialStateAsSnapshot">
            <summary>
            Get the initial state as a <see cref="T:Akka.Cluster.ClusterEvent.CurrentClusterState"/> message.
            </summary>
        </member>
        <member name="F:Akka.Cluster.ClusterEvent.InitialStateAsEvents">
            <summary>
            Get the current state of the cluster played back as a series of <see cref="T:Akka.Cluster.ClusterEvent.IMemberEvent"/>
            and <see cref="T:Akka.Cluster.ClusterEvent.IReachabilityEvent"/> messages.
            </summary>
        </member>
        <member name="T:Akka.Cluster.ClusterEvent.IClusterDomainEvent">
            <summary>
            Marker interface for cluster domain events
            </summary>
        </member>
        <member name="T:Akka.Cluster.ClusterEvent.CurrentClusterState">
            <summary>
            A snapshot of the current state of the <see cref="T:Akka.Cluster.Cluster"/>
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.CurrentClusterState.#ctor">
            <summary>
            Creates a new instance of the current cluster state.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.CurrentClusterState.#ctor(System.Collections.Immutable.ImmutableSortedSet{Akka.Cluster.Member},System.Collections.Immutable.ImmutableHashSet{Akka.Cluster.Member},System.Collections.Immutable.ImmutableHashSet{Akka.Actor.Address},Akka.Actor.Address,System.Collections.Immutable.ImmutableDictionary{System.String,Akka.Actor.Address})">
            <summary>
            Creates a new instance of the current cluster state.
            </summary>
            <param name="members">The current members of the cluster.</param>
            <param name="unreachable">The unreachable members of the cluster.</param>
            <param name="seenBy">The set of nodes who have seen us.</param>
            <param name="leader">The leader of the cluster.</param>
            <param name="roleLeaderMap">The list of role leaders.</param>
        </member>
        <member name="P:Akka.Cluster.ClusterEvent.CurrentClusterState.Members">
            <summary>
            Get current member list
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterEvent.CurrentClusterState.Unreachable">
            <summary>
            Get current unreachable set
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterEvent.CurrentClusterState.SeenBy">
            <summary>
            Get current "seen-by" set
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterEvent.CurrentClusterState.Leader">
            <summary>
            Get address of current leader, or null if noe
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterEvent.CurrentClusterState.AllRoles">
            <summary>
            All node roles in the cluster
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterEvent.CurrentClusterState.RoleLeaderMap">
            <summary>
            Needed internally inside the <see cref="T:Akka.Cluster.ClusterReadView"/>
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.CurrentClusterState.RoleLeader(System.String)">
            <summary>
            Get address of current leader, if any, within the role set
            </summary>
            <param name="role">The role we wish to check.</param>
            <returns>The address of the node who is the real leader, if any. Otherwise <c>null</c>.</returns>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.CurrentClusterState.Copy(System.Collections.Immutable.ImmutableSortedSet{Akka.Cluster.Member},System.Collections.Immutable.ImmutableHashSet{Akka.Cluster.Member},System.Collections.Immutable.ImmutableHashSet{Akka.Actor.Address},Akka.Actor.Address,System.Collections.Immutable.ImmutableDictionary{System.String,Akka.Actor.Address})">
            <summary>
            Creates a deep copy of the <see cref="T:Akka.Cluster.ClusterEvent.CurrentClusterState"/> and optionally allows you
            to specify different values for the outgoing objects
            </summary>
            <param name="members">TBD</param>
            <param name="unreachable">TBD</param>
            <param name="seenBy">TBD</param>
            <param name="leader">TBD</param>
            <param name="roleLeaderMap">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.ClusterEvent.IMemberEvent">
            <summary>
            This interface marks a given class as a membership event.
            The event is published when the state change is first seen on a node.
            The state change was performed by the leader when there was
            convergence on the leader node, i.e. all members had seen previous
            state.
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterEvent.IMemberEvent.Member">
            <summary>
            The node where the event occurred.
            </summary>
        </member>
        <member name="T:Akka.Cluster.ClusterEvent.MemberStatusChange">
            <summary>
            This class provides base functionality for defining state change events for cluster member nodes.
            </summary>
        </member>
        <member name="F:Akka.Cluster.ClusterEvent.MemberStatusChange._member">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.MemberStatusChange.#ctor(Akka.Cluster.Member,Akka.Cluster.MemberStatus)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Cluster.ClusterEvent.MemberStatusChange"/> class.
            </summary>
            <param name="member">The node that changed state.</param>
            <param name="validStatus">The state that the node changed towards.</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown if the node's current status doesn't match the given status, <paramref name="validStatus"/>.
            </exception>
        </member>
        <member name="P:Akka.Cluster.ClusterEvent.MemberStatusChange.Member">
            <summary>
            The cluster member node that changed status.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.MemberStatusChange.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" />, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.MemberStatusChange.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.</returns>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.MemberStatusChange.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>A <see cref="T:System.String" /> that represents this instance.</returns>
        </member>
        <member name="T:Akka.Cluster.ClusterEvent.MemberJoined">
            <summary>
            This class represents a <see cref="T:Akka.Cluster.ClusterEvent.MemberStatusChange"/> event where the
            cluster node changed its status to <see cref="F:Akka.Cluster.MemberStatus.Joining"/>.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.MemberJoined.#ctor(Akka.Cluster.Member)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Cluster.ClusterEvent.MemberJoined"/> class.
            </summary>
            <param name="member">The node that changed state.</param>
        </member>
        <member name="T:Akka.Cluster.ClusterEvent.MemberUp">
            <summary>
            This class represents a <see cref="T:Akka.Cluster.ClusterEvent.MemberStatusChange"/> event where the
            cluster node changed its status to <see cref="F:Akka.Cluster.MemberStatus.Up"/>.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.MemberUp.#ctor(Akka.Cluster.Member)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Cluster.ClusterEvent.MemberUp"/> class.
            </summary>
            <param name="member">The node that changed state.</param>
        </member>
        <member name="T:Akka.Cluster.ClusterEvent.MemberLeft">
            <summary>
            This class represents a <see cref="T:Akka.Cluster.ClusterEvent.MemberStatusChange"/> event where the
            cluster node changed its status to <see cref="F:Akka.Cluster.MemberStatus.Leaving"/>.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.MemberLeft.#ctor(Akka.Cluster.Member)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Cluster.ClusterEvent.MemberJoined"/> class.
            </summary>
            <param name="member">The node that changed state.</param>
        </member>
        <member name="T:Akka.Cluster.ClusterEvent.MemberExited">
            <summary>
            This class represents a <see cref="T:Akka.Cluster.ClusterEvent.MemberStatusChange"/> event where the
            cluster node changed its status to <see cref="F:Akka.Cluster.MemberStatus.Exiting"/>.
            The node is removed when all members have seen the <see cref="F:Akka.Cluster.MemberStatus.Exiting"/> status.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.MemberExited.#ctor(Akka.Cluster.Member)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Cluster.ClusterEvent.MemberJoined"/> class.
            </summary>
            <param name="member">The node that changed state.</param>
        </member>
        <member name="T:Akka.Cluster.ClusterEvent.MemberRemoved">
            <summary>
            <para>
            This class represents a <see cref="T:Akka.Cluster.ClusterEvent.MemberStatusChange"/> event where the
            cluster node changed its status to <see cref="F:Akka.Cluster.MemberStatus.Removed"/>.
            </para>
            <para>
            When <see cref="P:Akka.Cluster.ClusterEvent.MemberRemoved.PreviousStatus"/> is <see cref="F:Akka.Cluster.MemberStatus.Down"/>
            the node was removed after being detected as unreachable and downed.
            </para>
            <para>
            When <see cref="P:Akka.Cluster.ClusterEvent.MemberRemoved.PreviousStatus"/> is <see cref="F:Akka.Cluster.MemberStatus.Exiting"/>
            the node was removed after graceful leaving and exiting.
            </para>
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterEvent.MemberRemoved.PreviousStatus">
            <summary>
            The status of the node before the state change event.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.MemberRemoved.#ctor(Akka.Cluster.Member,Akka.Cluster.MemberStatus)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Cluster.ClusterEvent.MemberRemoved"/> class.
            </summary>
            <param name="member">The node that changed state.</param>
            <param name="previousStatus">The state that the node changed from.</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown if the node's current status doesn't match the <see cref="F:Akka.Cluster.MemberStatus.Removed"/> status.
            </exception>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.MemberRemoved.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" />, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.MemberRemoved.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="T:Akka.Cluster.ClusterEvent.LeaderChanged">
            <summary>
            Leader of the cluster members changed. Published when the state change
            is first seen on a node.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.LeaderChanged.#ctor(Akka.Actor.Address)">
            <summary>
            TBD
            </summary>
            <param name="leader">TBD</param>
        </member>
        <member name="P:Akka.Cluster.ClusterEvent.LeaderChanged.Leader">
            <summary>
            Address of current leader, or null if none
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.LeaderChanged.Equals(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.LeaderChanged.GetHashCode">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.LeaderChanged.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.ClusterEvent.RoleLeaderChanged">
            <summary>
            First member (leader) of the members within a role set changed.
            Published when the state change is first seen on a node.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.RoleLeaderChanged.#ctor(System.String,Akka.Actor.Address)">
            <summary>
            TBD
            </summary>
            <param name="role">TBD</param>
            <param name="leader">TBD</param>
        </member>
        <member name="P:Akka.Cluster.ClusterEvent.RoleLeaderChanged.Leader">
            <summary>
            Address of current leader, or null if none
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterEvent.RoleLeaderChanged.Role">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.RoleLeaderChanged.GetHashCode">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.RoleLeaderChanged.Equals(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.RoleLeaderChanged.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.ClusterEvent.ClusterShuttingDown">
            <summary>
            Indicates that the <see cref="T:Akka.Cluster.Cluster"/> plugin is shutting down.
            </summary>
        </member>
        <member name="F:Akka.Cluster.ClusterEvent.ClusterShuttingDown.Instance">
            <summary>
            Singleton instance.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.ClusterShuttingDown.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Akka.Cluster.ClusterEvent.IReachabilityEvent">
            <summary>
            A marker interface to facilitate the subscription of
            both <see cref="T:Akka.Cluster.ClusterEvent.UnreachableMember"/> and <see cref="T:Akka.Cluster.ClusterEvent.ReachableMember"/>.
            </summary>
        </member>
        <member name="T:Akka.Cluster.ClusterEvent.ReachabilityEvent">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.ReachabilityEvent.#ctor(Akka.Cluster.Member)">
            <summary>
            TBD
            </summary>
            <param name="member">TBD</param>
        </member>
        <member name="P:Akka.Cluster.ClusterEvent.ReachabilityEvent.Member">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.ReachabilityEvent.Equals(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.ReachabilityEvent.GetHashCode">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.ReachabilityEvent.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.ClusterEvent.UnreachableMember">
            <summary>
            A member is considered as unreachable by the failure detector.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.UnreachableMember.#ctor(Akka.Cluster.Member)">
            <summary>
            TBD
            </summary>
            <param name="member">TBD</param>
        </member>
        <member name="T:Akka.Cluster.ClusterEvent.ReachableMember">
            <summary>
            A member is considered as reachable by the failure detector
            after having been unreachable.
            <see cref="T:Akka.Cluster.ClusterEvent.UnreachableMember"/>
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.ReachableMember.#ctor(Akka.Cluster.Member)">
            <summary>
            TBD
            </summary>
            <param name="member">TBD</param>
        </member>
        <member name="T:Akka.Cluster.ClusterEvent.SeenChanged">
            <summary>
            The nodes that have seen current version of the Gossip.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.SeenChanged.#ctor(System.Boolean,System.Collections.Immutable.ImmutableHashSet{Akka.Actor.Address})">
            <summary>
            TBD
            </summary>
            <param name="convergence">TBD</param>
            <param name="seenBy">TBD</param>
        </member>
        <member name="P:Akka.Cluster.ClusterEvent.SeenChanged.Convergence">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterEvent.SeenChanged.SeenBy">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.SeenChanged.Equals(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.SeenChanged.GetHashCode">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.ClusterEvent.ReachabilityChanged">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.ReachabilityChanged.#ctor(Akka.Cluster.Reachability)">
            <summary>
            TBD
            </summary>
            <param name="reachability">TBD</param>
        </member>
        <member name="P:Akka.Cluster.ClusterEvent.ReachabilityChanged.Reachability">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.ReachabilityChanged.Equals(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.ReachabilityChanged.GetHashCode">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.ClusterEvent.CurrentInternalStats">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.CurrentInternalStats.#ctor(Akka.Cluster.GossipStats,Akka.Cluster.VectorClockStats)">
            <summary>
            TBD
            </summary>
            <param name="gossipStats">TBD</param>
            <param name="vclockStats">TBD</param>
        </member>
        <member name="P:Akka.Cluster.ClusterEvent.CurrentInternalStats.GossipStats">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterEvent.CurrentInternalStats.SeenBy">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.CurrentInternalStats.GetHashCode">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.CurrentInternalStats.Equals(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.DiffUnreachable(Akka.Cluster.Gossip,Akka.Cluster.Gossip,Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="oldGossip">TBD</param>
            <param name="newGossip">TBD</param>
            <param name="selfUniqueAddress">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.DiffReachable(Akka.Cluster.Gossip,Akka.Cluster.Gossip,Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="oldGossip">TBD</param>
            <param name="newGossip">TBD</param>
            <param name="selfUniqueAddress">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.DiffMemberEvents(Akka.Cluster.Gossip,Akka.Cluster.Gossip)">
            <summary>
            Compares two <see cref="T:Akka.Cluster.Gossip"/> instances and uses them to publish the appropriate <see cref="T:Akka.Cluster.ClusterEvent.IMemberEvent"/>
            for any given change to the membership of the current cluster.
            </summary>
            <param name="oldGossip">The previous gossip instance.</param>
            <param name="newGossip">The new gossip instance.</param>
            <returns>A possibly empty set of membership events to be published to all subscribers.</returns>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.DiffLeader(Akka.Cluster.Gossip,Akka.Cluster.Gossip,Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="oldGossip">TBD</param>
            <param name="newGossip">TBD</param>
            <param name="selfUniqueAddress">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.DiffRolesLeader(Akka.Cluster.Gossip,Akka.Cluster.Gossip,Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="oldGossip">TBD</param>
            <param name="newGossip">TBD</param>
            <param name="selfUniqueAddress">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="F:Akka.Cluster.ClusterEvent.EmptySet">
            <summary>
            Used for checking convergence when we don't have any information from the cluster daemon.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.DiffSeen(Akka.Cluster.Gossip,Akka.Cluster.Gossip,Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="oldGossip">TBD</param>
            <param name="newGossip">TBD</param>
            <param name="selfUniqueAddress">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.ClusterEvent.DiffReachability(Akka.Cluster.Gossip,Akka.Cluster.Gossip)">
            <summary>
            TBD
            </summary>
            <param name="oldGossip">TBD</param>
            <param name="newGossip">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.ClusterDomainEventPublisher">
            <summary>
            INTERNAL API.
            
            Publishes <see cref="T:Akka.Cluster.ClusterEvent"/>s out to all subscribers.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterDomainEventPublisher.#ctor">
            <summary>
            Default constructor for ClusterDomainEventPublisher.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterDomainEventPublisher.PreRestart(System.Exception,System.Object)">
            <inheritdoc cref="M:Akka.Actor.ActorBase.PreRestart(System.Exception,System.Object)"/>
        </member>
        <member name="M:Akka.Cluster.ClusterDomainEventPublisher.PostStop">
            <inheritdoc cref="M:Akka.Actor.ActorBase.PostStop"/>
        </member>
        <member name="M:Akka.Cluster.ClusterDomainEventPublisher.SendCurrentClusterState(Akka.Actor.IActorRef)">
            <summary>
            The current snapshot state corresponding to latest gossip 
            to mimic what you would have seen if you were listening to the events.
            </summary>
        </member>
        <member name="T:Akka.Cluster.ClusterHeartbeatReceiver">
            <summary>
            INTERNAL API
            
            Receives <see cref="T:Akka.Cluster.ClusterHeartbeatSender.Heartbeat"/> messages and replies.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterHeartbeatReceiver.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Cluster.ClusterHeartbeatSender">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterHeartbeatSender.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterHeartbeatSender.PreStart">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterHeartbeatSender.PostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterHeartbeatSender.HeartbeatReceiver(Akka.Actor.Address)">
            <summary>
            Looks up and returns the remote cluster heartbeat connection for the specific address.
            </summary>
        </member>
        <member name="T:Akka.Cluster.ClusterHeartbeatSender.Heartbeat">
            <summary>
            Sent at regular intervals for failure detection
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterHeartbeatSender.Heartbeat.#ctor(Akka.Actor.Address)">
            <summary>
            TBD
            </summary>
            <param name="from">TBD</param>
        </member>
        <member name="P:Akka.Cluster.ClusterHeartbeatSender.Heartbeat.From">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterHeartbeatSender.Heartbeat.Equals(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.ClusterHeartbeatSender.HeartbeatRsp">
            <summary>
            Sends replies to <see cref="T:Akka.Cluster.ClusterHeartbeatSender.Heartbeat"/> messages
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterHeartbeatSender.HeartbeatRsp.#ctor(Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="from">TBD</param>
        </member>
        <member name="P:Akka.Cluster.ClusterHeartbeatSender.HeartbeatRsp.From">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterHeartbeatSender.HeartbeatRsp.Equals(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.ClusterHeartbeatSender.HeartbeatTick">
            <summary>
            Sent to self only
            </summary>
        </member>
        <member name="T:Akka.Cluster.ClusterHeartbeatSender.ExpectedFirstHeartbeat">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterHeartbeatSender.ExpectedFirstHeartbeat.#ctor(Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="from">TBD</param>
        </member>
        <member name="P:Akka.Cluster.ClusterHeartbeatSender.ExpectedFirstHeartbeat.From">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Cluster.ClusterHeartbeatSenderState">
            <summary>
            INTERNAL API
            State of <see cref="T:Akka.Cluster.ClusterHeartbeatSender"/>. Encapsulated to facilitate unit testing.
            It is immutable, but it updates the failure detector.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterHeartbeatSenderState.#ctor(Akka.Cluster.HeartbeatNodeRing,System.Collections.Immutable.ImmutableHashSet{Akka.Cluster.UniqueAddress},Akka.Remote.IFailureDetectorRegistry{Akka.Actor.Address})">
            <summary>
            TBD
            </summary>
            <param name="ring">TBD</param>
            <param name="oldReceiversNowUnreachable">TBD</param>
            <param name="failureDetector">TBD</param>
        </member>
        <member name="P:Akka.Cluster.ClusterHeartbeatSenderState.Ring">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterHeartbeatSenderState.OldReceiversNowUnreachable">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterHeartbeatSenderState.FailureDetector">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Cluster.ClusterHeartbeatSenderState.ActiveReceivers">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterHeartbeatSenderState.SelfAddress">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterHeartbeatSenderState.Init(System.Collections.Immutable.ImmutableHashSet{Akka.Cluster.UniqueAddress},System.Collections.Immutable.ImmutableHashSet{Akka.Cluster.UniqueAddress})">
            <summary>
            TBD
            </summary>
            <param name="nodes">TBD</param>
            <param name="unreachable">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.ClusterHeartbeatSenderState.Contains(Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="node">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.ClusterHeartbeatSenderState.AddMember(Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="node">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.ClusterHeartbeatSenderState.RemoveMember(Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="node">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.ClusterHeartbeatSenderState.UnreachableMember(Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="node">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.ClusterHeartbeatSenderState.ReachableMember(Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="node">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.ClusterHeartbeatSenderState.HeartbeatRsp(Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="from">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.ClusterHeartbeatSenderState.Copy(Akka.Cluster.HeartbeatNodeRing,System.Collections.Immutable.ImmutableHashSet{Akka.Cluster.UniqueAddress},Akka.Remote.IFailureDetectorRegistry{Akka.Actor.Address})">
            <summary>
            TBD
            </summary>
            <param name="ring">TBD</param>
            <param name="oldReceiversNowUnreachable">TBD</param>
            <param name="failureDetector">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.HeartbeatNodeRing">
            <summary>
            INTERNAL API
            
            Data structure for picking heartbeat receivers. The node ring is shuffled
            by deterministic hashing to avoid picking physically co-located neighbors.
            
            It is immutable, i.e. the methods all return new instances.
            </summary>
        </member>
        <member name="M:Akka.Cluster.HeartbeatNodeRing.#ctor(Akka.Cluster.UniqueAddress,System.Collections.Immutable.ImmutableHashSet{Akka.Cluster.UniqueAddress},System.Collections.Immutable.ImmutableHashSet{Akka.Cluster.UniqueAddress},System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="selfAddress">TBD</param>
            <param name="nodes">TBD</param>
            <param name="unreachable">TBD</param>
            <param name="monitoredByNumberOfNodes">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
        </member>
        <member name="P:Akka.Cluster.HeartbeatNodeRing.SelfAddress">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.HeartbeatNodeRing.Nodes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.HeartbeatNodeRing.Unreachable">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.HeartbeatNodeRing.MonitoredByNumberOfNodes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Cluster.HeartbeatNodeRing.MyReceivers">
            <summary>
            Receivers for <see cref="P:Akka.Cluster.HeartbeatNodeRing.SelfAddress"/>. Cached for subsequent access.
            </summary>
        </member>
        <member name="M:Akka.Cluster.HeartbeatNodeRing.Receivers(Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="sender">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.HeartbeatNodeRing.Copy(Akka.Cluster.UniqueAddress,System.Collections.Immutable.ImmutableHashSet{Akka.Cluster.UniqueAddress},System.Collections.Immutable.ImmutableHashSet{Akka.Cluster.UniqueAddress},System.Nullable{System.Int32})">
            <summary>
            TBD
            </summary>
            <param name="selfAddress">TBD</param>
            <param name="nodes">TBD</param>
            <param name="unreachable">TBD</param>
            <param name="monitoredByNumberOfNodes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.HeartbeatNodeRing.op_Addition(Akka.Cluster.HeartbeatNodeRing,Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="ring">TBD</param>
            <param name="node">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.HeartbeatNodeRing.op_Subtraction(Akka.Cluster.HeartbeatNodeRing,Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="ring">TBD</param>
            <param name="node">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.HeartbeatNodeRing.RingComparer">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Cluster.HeartbeatNodeRing.RingComparer.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.HeartbeatNodeRing.RingComparer.Compare(Akka.Cluster.UniqueAddress,Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="a">TBD</param>
            <param name="b">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.ClusterReadView">
            <summary>
            INTERNAL API
            
            Read view of the cluster's state, updated via subscription of
            cluster events published on the <see cref="T:Akka.Event.EventBus`3"/>.
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterReadView.State">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Cluster.ClusterReadView._state">
            <summary>
            Current state
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterReadView.Reachability">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Cluster.ClusterReadView._reachability">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterReadView.LatestStats">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="F:Akka.Cluster.ClusterReadView._latestStats">
            <summary>
            Current internal cluster stats, updated periodically via event bus.
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterReadView.SelfAddress">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterReadView.#ctor(Akka.Cluster.Cluster)">
            <summary>
            TBD
            </summary>
            <param name="cluster">TBD</param>
        </member>
        <member name="T:Akka.Cluster.ClusterReadView.EventBusListener">
            <summary>
            actor that subscribers to cluster eventBus to update current read view state
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterReadView.Self">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterReadView.IsTerminated">
            <summary>
            Returns true if this cluster instance has been shutdown.
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterReadView.Members">
            <summary>
            Current cluster members, sorted by address
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterReadView.UnreachableMembers">
            <summary>
            Members that have been detected as unreachable
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterReadView.Status">
            <summary>
            <see cref="T:Akka.Cluster.MemberStatus"/> for this node.
            
            NOTE: If the node has been removed from the cluster (and shut down) then it's status is set to the 'REMOVED' tombstone state
            and is no longer present in the node ring or any other part of the gossiping state. However in order to maintain the
            model and the semantics the user would expect, this method will in this situation return <see cref="F:Akka.Cluster.MemberStatus.Removed"/>.
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterReadView.Leader">
            <summary>
            Get the address of the current leader.
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterReadView.IsLeader">
            <summary>
            Is this node the leader?
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterReadView.IsSingletonCluster">
            <summary>
            Does the cluster consist of only one member?
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterReadView.IsAvailable">
            <summary>
            Returns true if the node is no reachable and not <see cref="F:Akka.Cluster.MemberStatus.Down"/>
            and not <see cref="F:Akka.Cluster.MemberStatus.Removed"/>
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterReadView.RefreshCurrentState">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterReadView.SeenBy">
            <summary>
            INTERNAL API
            The nodes that have seen current version of the <see cref="T:Akka.Cluster.Gossip"/>
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterReadView.Dispose">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterReadView.Dispose(System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="disposing">TBD</param>
        </member>
        <member name="T:Akka.Cluster.ClusterRemoteWatcher">
            <summary>
            Specialization of <see cref="T:Akka.Remote.RemoteWatcher"/> that keeps
            track of cluster member nodes and is responsible for watchees on cluster nodes.
            <see cref="T:Akka.Actor.AddressTerminated"/> is published when a node is removed from cluster
            
            `RemoteWatcher` handles non-cluster nodes. `ClusterRemoteWatcher` will take
            over responsibility from `RemoteWatcher` if a watch is added before a node is member
            of the cluster and then later becomes cluster member.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterRemoteWatcher.Props(Akka.Remote.IFailureDetectorRegistry{Akka.Actor.Address},System.TimeSpan,System.TimeSpan,System.TimeSpan)">
            <summary>
            Factory method for <see cref="T:Akka.Remote.RemoteWatcher"/>
            </summary>
            <param name="failureDetector">TBD</param>
            <param name="heartbeatInterval">TBD</param>
            <param name="unreachableReaperInterval">TBD</param>
            <param name="heartbeatExpectedResponseAfter">TBD</param>
        </member>
        <member name="M:Akka.Cluster.ClusterRemoteWatcher.#ctor(Akka.Remote.IFailureDetectorRegistry{Akka.Actor.Address},System.TimeSpan,System.TimeSpan,System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="failureDetector">TBD</param>
            <param name="heartbeatInterval">TBD</param>
            <param name="unreachableReaperInterval">TBD</param>
            <param name="heartbeatExpectedResponseAfter">TBD</param>
        </member>
        <member name="M:Akka.Cluster.ClusterRemoteWatcher.PreStart">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterRemoteWatcher.PostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterRemoteWatcher.OnReceive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
        </member>
        <member name="M:Akka.Cluster.ClusterRemoteWatcher.WatchNode(Akka.Actor.IInternalActorRef)">
            <summary>
            TBD
            </summary>
            <param name="watchee">TBD</param>
        </member>
        <member name="M:Akka.Cluster.ClusterRemoteWatcher.TakeOverResponsibility(Akka.Actor.Address)">
            <summary>
            When a cluster node is added this class takes over the
            responsibility for watchees on that node already handled
            by base RemoteWatcher.
            </summary>
        </member>
        <member name="T:Akka.Cluster.ClusterSettings">
            <summary>
            This class represents configuration information used when setting up a cluster.
            </summary>
        </member>
        <member name="M:Akka.Cluster.ClusterSettings.#ctor(Akka.Configuration.Config,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Cluster.ClusterSettings"/> class.
            </summary>
            <param name="config">The configuration to use when setting up the cluster.</param>
            <param name="systemName">The name of the actor system hosting the cluster.</param>
        </member>
        <member name="P:Akka.Cluster.ClusterSettings.LogInfo">
            <summary>
            Determine whether to log <see cref="F:Akka.Event.LogLevel.InfoLevel"/> messages.
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterSettings.FailureDetectorConfig">
            <summary>
            The configuration for the underlying failure detector used by Akka.Cluster.
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterSettings.FailureDetectorImplementationClass">
            <summary>
            The fully qualified type name of the failure detector class that will be used.
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterSettings.HeartbeatInterval">
            <summary>
            The amount of time between when heartbeat messages are sent.
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterSettings.HeartbeatExpectedResponseAfter">
            <summary>
            The amount of time we expect a heartbeat response after first contact with a new node.
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterSettings.MonitoredByNrOfMembers">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterSettings.SeedNodes">
            <summary>
            A list of designated seed nodes for the cluster.
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterSettings.SeedNodeTimeout">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterSettings.RetryUnsuccessfulJoinAfter">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterSettings.PeriodicTasksInitialDelay">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterSettings.GossipInterval">
            <summary>
            The amount of time between when gossip messages are sent.
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterSettings.GossipTimeToLive">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterSettings.LeaderActionsInterval">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterSettings.UnreachableNodesReaperInterval">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterSettings.PublishStatsInterval">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterSettings.AutoDownUnreachableAfter">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterSettings.Roles">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterSettings.GossipDifferentViewProbability">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterSettings.ReduceGossipDifferentViewProbability">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterSettings.UseDispatcher">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterSettings.SchedulerTickDuration">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterSettings.SchedulerTicksPerWheel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterSettings.MinNrOfMembers">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterSettings.MinNrOfMembersOfRole">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterSettings.DownRemovalMargin">
            <summary>
            Obsolete. Use <see cref="P:Cluster.DowningProvider.DownRemovalMargin"/>.
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterSettings.VerboseHeartbeatLogging">
            <summary>
            Determine whether or not to log heartbeat message in verbose mode.
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterSettings.DowningProviderType">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.ClusterSettings.RunCoordinatedShutdownWhenDown">
            <summary>
            Trigger the <see cref="T:Akka.Actor.CoordinatedShutdown"/> even if this node was removed by non-graceful
            means, such as being downed.
            </summary>
        </member>
        <member name="T:Akka.Cluster.Configuration.ClusterConfigFactory">
             <summary>
             This class contains methods used to retrieve cluster configuration options from this assembly's resources.
            
             <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
             </summary>
        </member>
        <member name="M:Akka.Cluster.Configuration.ClusterConfigFactory.Default">
            <summary>
            Retrieves the default cluster options that Akka.NET uses when no configuration has been defined.
            </summary>
            <returns>The configuration that contains default values for all cluster options.</returns>
        </member>
        <member name="M:Akka.Cluster.Configuration.ClusterConfigFactory.FromResource(System.String)">
            <summary>
            Retrieves a configuration defined in a resource of the current executing assembly.
            </summary>
            <param name="resourceName">The name of the resource that contains the configuration.</param>
            <returns>The configuration defined in the current executing assembly.</returns>
        </member>
        <member name="T:Akka.Cluster.CoordinatedShutdownLeave">
            <summary>
            INTERNAL API
            
            Used for executing <see cref="T:Akka.Actor.CoordinatedShutdown"/> phases for graceful
            <see cref="M:Akka.Cluster.Cluster.Leave(Akka.Actor.Address)"/> behaviors.
            </summary>
        </member>
        <member name="T:Akka.Cluster.CoordinatedShutdownLeave.LeaveReq">
            <summary>
            A leave request for beginning the exit process from the <see cref="T:Akka.Cluster.Cluster"/>
            </summary>
        </member>
        <member name="F:Akka.Cluster.CoordinatedShutdownLeave.LeaveReq.Instance">
            <summary>
            Singleton instance.
            </summary>
        </member>
        <member name="T:Akka.Cluster.IDowningProvider">
            <summary>
            API for plugins that will handle downing of cluster nodes. Concrete plugins must subclass and
            have a public one argument constructor accepting an <see cref="T:Akka.Actor.ActorSystem"/>.
            </summary>
        </member>
        <member name="P:Akka.Cluster.IDowningProvider.DownRemovalMargin">
            <summary>
            Time margin after which shards or singletons that belonged to a downed/removed
            partition are created in surviving partition. The purpose of this margin is that
            in case of a network partition the persistent actors in the non-surviving partitions
            must be stopped before corresponding persistent actors are started somewhere else.
            This is useful if you implement downing strategies that handle network partitions,
            e.g. by keeping the larger side of the partition and shutting down the smaller side.
            </summary>
        </member>
        <member name="P:Akka.Cluster.IDowningProvider.DowningActorProps">
            <summary>
            If a props is returned it is created as a child of the core cluster daemon on cluster startup.
            It should then handle downing using the regular <see cref="T:Akka.Cluster.Cluster"/> APIs.
            The actor will run on the same dispatcher as the cluster actor if dispatcher not configured.
            
            May throw an exception which will then immediately lead to Cluster stopping, as the downing
            provider is vital to a working cluster.
            </summary>
        </member>
        <member name="T:Akka.Cluster.NoDowning">
            <summary>
            Default downing provider used when no provider is configured and 'auto-down-unreachable-after'
            is not enabled.
            </summary>
        </member>
        <member name="M:Akka.Cluster.NoDowning.#ctor(Akka.Actor.ActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
        </member>
        <member name="P:Akka.Cluster.NoDowning.DownRemovalMargin">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.NoDowning.DowningActorProps">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Cluster.DowningProvider">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.DowningProvider.Load(System.Type,Akka.Actor.ActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="downingProviderType">TBD</param>
            <param name="system">TBD</param>
            <exception cref="T:Akka.Configuration.ConfigurationException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.Gossip">
             <summary>
             Represents the state of the cluster; cluster ring membership, ring convergence -
             all versioned by a vector clock.
            
             When a node is joining the `Member`, with status `Joining`, is added to `members`.
             If the joining node was downed it is moved from `overview.unreachable` (status `Down`)
             to `members` (status `Joining`). It cannot rejoin if not first downed.
            
             When convergence is reached the leader change status of `members` from `Joining`
             to `Up`.
            
             When failure detector consider a node as unavailable it will be moved from
             `members` to `overview.unreachable`.
            
             When a node is downed, either manually or automatically, its status is changed to `Down`.
             It is also removed from `overview.seen` table. The node will reside as `Down` in the
             `overview.unreachable` set until joining again and it will then go through the normal
             joining procedure.
            
             When a `Gossip` is received the version (vector clock) is used to determine if the
             received `Gossip` is newer or older than the current local `Gossip`. The received `Gossip`
             and local `Gossip` is merged in case of conflicting version, i.e. vector clocks without
             same history.
            
             When a node is told by the user to leave the cluster the leader will move it to `Leaving`
             and then rebalance and repartition the cluster and start hand-off by migrating the actors
             from the leaving node to the new partitions. Once this process is complete the leader will
             move the node to the `Exiting` state and once a convergence is complete move the node to
             `Removed` by removing it from the `members` set and sending a `Removed` command to the
             removed node telling it to shut itself down.
             </summary>
        </member>
        <member name="F:Akka.Cluster.Gossip.EmptyMembers">
            <summary>
            An empty set of members
            </summary>
        </member>
        <member name="F:Akka.Cluster.Gossip.Empty">
            <summary>
            An empty <see cref="T:Akka.Cluster.Gossip"/> object.
            </summary>
        </member>
        <member name="M:Akka.Cluster.Gossip.Create(System.Collections.Immutable.ImmutableSortedSet{Akka.Cluster.Member})">
            <summary>
            Creates a new <see cref="T:Akka.Cluster.Gossip"/> from the given set of members.
            </summary>
            <param name="members">The current membership of the cluster.</param>
            <returns>A gossip object for the given members.</returns>
        </member>
        <member name="F:Akka.Cluster.Gossip.ConvergenceSkipUnreachableWithMemberStatus">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Cluster.Gossip.RemoveUnreachableWithMemberStatus">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.Gossip.Members">
            <summary>
            The current members of the cluster
            </summary>
        </member>
        <member name="P:Akka.Cluster.Gossip.Overview">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.Gossip.Version">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.Gossip.#ctor(System.Collections.Immutable.ImmutableSortedSet{Akka.Cluster.Member})">
            <summary>
            TBD
            </summary>
            <param name="members">TBD</param>
        </member>
        <member name="M:Akka.Cluster.Gossip.#ctor(System.Collections.Immutable.ImmutableSortedSet{Akka.Cluster.Member},Akka.Cluster.GossipOverview)">
            <summary>
            TBD
            </summary>
            <param name="members">TBD</param>
            <param name="overview">TBD</param>
        </member>
        <member name="M:Akka.Cluster.Gossip.#ctor(System.Collections.Immutable.ImmutableSortedSet{Akka.Cluster.Member},Akka.Cluster.GossipOverview,Akka.Cluster.VectorClock)">
            <summary>
            TBD
            </summary>
            <param name="members">TBD</param>
            <param name="overview">TBD</param>
            <param name="version">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
        </member>
        <member name="M:Akka.Cluster.Gossip.Copy(System.Collections.Immutable.ImmutableSortedSet{Akka.Cluster.Member},Akka.Cluster.GossipOverview,Akka.Cluster.VectorClock)">
            <summary>
            TBD
            </summary>
            <param name="members">TBD</param>
            <param name="overview">TBD</param>
            <param name="version">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Gossip.Increment(Akka.Cluster.VectorClock.Node)">
            <summary>
            Increments the version for this 'Node'.
            </summary>
            <param name="node">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Gossip.AddMember(Akka.Cluster.Member)">
            <summary>
            Adds a member to the member node ring.
            </summary>
            <param name="member">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Gossip.Seen(Akka.Cluster.UniqueAddress)">
            <summary>
            Marks the gossip as seen by this node (address) by updating the address entry in the 'gossip.overview.seen'
            </summary>
            <param name="node">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Gossip.OnlySeen(Akka.Cluster.UniqueAddress)">
            <summary>
            Marks the gossip as seen by only this node (address) by replacing the 'gossip.overview.seen'
            </summary>
            <param name="node">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Gossip.ClearSeen">
            <summary>
            Removes all seen entries from the gossip.
            </summary>
            <returns>A copy of the current gossip with no seen entries.</returns>
        </member>
        <member name="P:Akka.Cluster.Gossip.SeenBy">
            <summary>
            The nodes that have seen the current version of the Gossip.
            </summary>
        </member>
        <member name="M:Akka.Cluster.Gossip.SeenByNode(Akka.Cluster.UniqueAddress)">
            <summary>
            Has this Gossip been seen by this node.
            </summary>
            <param name="node">The unique address of the node.</param>
            <returns><c>true</c> if this gossip has been seen by the given node, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Cluster.Gossip.MergeSeen(Akka.Cluster.Gossip)">
            <summary>
            TBD
            </summary>
            <param name="that">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Gossip.Merge(Akka.Cluster.Gossip)">
            <summary>
            Merges two <see cref="T:Akka.Cluster.Gossip"/> objects together into a consistent view of the <see cref="T:Akka.Cluster.Cluster"/>.
            </summary>
            <param name="that">The other gossip object to be merged.</param>
            <returns>A combined gossip object that uses the underlying <see cref="T:Akka.Cluster.VectorClock"/> to determine which items are newest.</returns>
        </member>
        <member name="M:Akka.Cluster.Gossip.Convergence(Akka.Cluster.UniqueAddress,System.Collections.Generic.HashSet{Akka.Cluster.UniqueAddress})">
            <summary>
            First check that:
              1. we don't have any members that are unreachable, or
              2. all unreachable members in the set have status DOWN or EXITING
            Else we can't continue to check for convergence. When that is done 
            we check that all members with a convergence status is in the seen 
            table and has the latest vector clock version.
            </summary>
            <param name="selfUniqueAddress">The unique address of the node checking for convergence.</param>
            <param name="exitingConfirmed">The set of nodes who have been confirmed to be exiting.</param>
            <returns><c>true</c> if convergence has been achieved. <c>false</c> otherwise.</returns>
        </member>
        <member name="P:Akka.Cluster.Gossip.ReachabilityExcludingDownedObservers">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.Gossip.IsLeader(Akka.Cluster.UniqueAddress,Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="node">TBD</param>
            <param name="selfUniqueAddress">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Gossip.Leader(Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="selfUniqueAddress">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Gossip.RoleLeader(System.String,Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="role">TBD</param>
            <param name="selfUniqueAddress">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Gossip.LeaderOf(System.Collections.Immutable.ImmutableSortedSet{Akka.Cluster.Member},Akka.Cluster.UniqueAddress)">
            <summary>
            Determine which node is the leader of the given range of members.
            </summary>
            <param name="mbrs">All members in the cluster.</param>
            <param name="selfUniqueAddress">The address of the current node.</param>
            <returns><c>null</c> if <see cref="!:mbrs"/> is empty. The <see cref="T:Akka.Cluster.UniqueAddress"/> of the leader otherwise.</returns>
        </member>
        <member name="P:Akka.Cluster.Gossip.AllRoles">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.Gossip.IsSingletonCluster">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.Gossip.GetMember(Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="node">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Gossip.HasMember(Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="node">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Cluster.Gossip.YoungestMember">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.Gossip.Prune(Akka.Cluster.VectorClock.Node)">
            <summary>
            TBD
            </summary>
            <param name="removedNode">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Gossip.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.GossipOverview">
            <summary>
            Represents the overview of the cluster, holds the cluster convergence table and set with unreachable nodes.
            </summary>
        </member>
        <member name="M:Akka.Cluster.GossipOverview.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.GossipOverview.#ctor(Akka.Cluster.Reachability)">
            <summary>
            TBD
            </summary>
            <param name="reachability">TBD</param>
        </member>
        <member name="M:Akka.Cluster.GossipOverview.#ctor(System.Collections.Immutable.ImmutableHashSet{Akka.Cluster.UniqueAddress},Akka.Cluster.Reachability)">
            <summary>
            TBD
            </summary>
            <param name="seen">TBD</param>
            <param name="reachability">TBD</param>
        </member>
        <member name="M:Akka.Cluster.GossipOverview.Copy(System.Collections.Immutable.ImmutableHashSet{Akka.Cluster.UniqueAddress},Akka.Cluster.Reachability)">
            <summary>
            TBD
            </summary>
            <param name="seen">TBD</param>
            <param name="reachability">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Cluster.GossipOverview.Seen">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.GossipOverview.Reachability">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Cluster.GossipEnvelope">
            <summary>
            Envelope adding a sender and receiver address to the gossip.
            The reason for including the receiver address is to be able to
            ignore messages that were intended for a previous incarnation of
            the node with same host:port. The `uid` in the `UniqueAddress` is
            different in that case.
            </summary>
        </member>
        <member name="M:Akka.Cluster.GossipEnvelope.#ctor(Akka.Cluster.UniqueAddress,Akka.Cluster.UniqueAddress,Akka.Cluster.Gossip,Akka.Remote.Deadline)">
            <summary>
            TBD
            </summary>
            <param name="from">TBD</param>
            <param name="to">TBD</param>
            <param name="gossip">TBD</param>
            <param name="deadline">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Cluster.GossipEnvelope.From">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.GossipEnvelope.To">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.GossipEnvelope.Gossip">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.GossipEnvelope.Deadline">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Cluster.GossipStatus">
            <summary>
            When there are no known changes to the node ring a `GossipStatus`
            initiates a gossip chat between two members. If the receiver has a newer
            version it replies with a `GossipEnvelope`. If receiver has older version
            it replies with its `GossipStatus`. Same versions ends the chat immediately.
            </summary>
        </member>
        <member name="P:Akka.Cluster.GossipStatus.From">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.GossipStatus.Version">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.GossipStatus.#ctor(Akka.Cluster.UniqueAddress,Akka.Cluster.VectorClock)">
            <summary>
            TBD
            </summary>
            <param name="from">TBD</param>
            <param name="version">TBD</param>
        </member>
        <member name="M:Akka.Cluster.GossipStatus.Equals(Akka.Cluster.GossipStatus)">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.GossipStatus.Equals(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.GossipStatus.GetHashCode">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.Member">
            <summary>
            Represents the address, current status, and roles of a cluster member node.
            
            Note: `hashCode` and `equals` are solely based on the underlying `Address`, not its `MemberStatus`
            and roles.
            </summary>
        </member>
        <member name="M:Akka.Cluster.Member.Create(Akka.Cluster.UniqueAddress,System.Collections.Immutable.ImmutableHashSet{System.String})">
            <summary>
            TBD
            </summary>
            <param name="uniqueAddress">TBD</param>
            <param name="roles">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Member.Removed(Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="node">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Cluster.Member.UniqueAddress">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.Member.UpNumber">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.Member.Status">
            <summary>
            The status of the current member.
            </summary>
        </member>
        <member name="P:Akka.Cluster.Member.Roles">
            <summary>
            The set of roles for the current member. Can be empty.
            </summary>
        </member>
        <member name="M:Akka.Cluster.Member.Create(Akka.Cluster.UniqueAddress,System.Int32,Akka.Cluster.MemberStatus,System.Collections.Immutable.ImmutableHashSet{System.String})">
            <summary>
            TBD
            </summary>
            <param name="uniqueAddress">TBD</param>
            <param name="upNumber">TBD</param>
            <param name="status">TBD</param>
            <param name="roles">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Member.#ctor(Akka.Cluster.UniqueAddress,System.Int32,Akka.Cluster.MemberStatus,System.Collections.Immutable.ImmutableHashSet{System.String})">
            <summary>
            TBD
            </summary>
            <param name="uniqueAddress">TBD</param>
            <param name="upNumber">TBD</param>
            <param name="status">TBD</param>
            <param name="roles">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Cluster.Member.Address">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.Member.GetHashCode">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Member.Equals(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Member.CompareTo(Akka.Cluster.Member)">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Member.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Member.HasRole(System.String)">
            <summary>
            TBD
            </summary>
            <param name="role">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Member.IsOlderThan(Akka.Cluster.Member)">
            <summary>
            Is this member older, has been part of cluster longer, than another
            member. It is only correct when comparing two existing members in a
            cluster. A member that joined after removal of another member may be
            considered older than the removed member.
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Member.Copy(Akka.Cluster.MemberStatus)">
            <summary>
            TBD
            </summary>
            <param name="status">TBD</param>
            <exception cref="T:System.InvalidOperationException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Member.CopyUp(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="upNumber">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="F:Akka.Cluster.Member.AddressOrdering">
            <summary>
             `Address` ordering type class, sorts addresses by host and port.
            </summary>
        </member>
        <member name="T:Akka.Cluster.Member.AddressComparer">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.Member.AddressComparer.Compare(Akka.Actor.Address,Akka.Actor.Address)">
            <summary>
            TBD
            </summary>
            <param name="x">TBD</param>
            <param name="y">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="F:Akka.Cluster.Member.AgeOrdering">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Cluster.Member.AgeComparer">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.Member.AgeComparer.Compare(Akka.Cluster.Member,Akka.Cluster.Member)">
            <summary>
            TBD
            </summary>
            <param name="a">TBD</param>
            <param name="b">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="F:Akka.Cluster.Member.LeaderStatusOrdering">
            <summary>
            Orders the members by their address except that members with status
            Joining, Exiting and Down are ordered last (in that order).
            </summary>
        </member>
        <member name="T:Akka.Cluster.Member.LeaderStatusMemberComparer">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.Member.LeaderStatusMemberComparer.Compare(Akka.Cluster.Member,Akka.Cluster.Member)">
            <summary>
            TBD
            </summary>
            <param name="a">TBD</param>
            <param name="b">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="F:Akka.Cluster.Member.Ordering">
            <summary>
            `Member` ordering type class, sorts members by host and port.
            </summary>
        </member>
        <member name="T:Akka.Cluster.Member.MemberComparer">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.Member.MemberComparer.Compare(Akka.Cluster.Member,Akka.Cluster.Member)">
            <summary>
            TBD
            </summary>
            <param name="x">TBD</param>
            <param name="y">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Member.PickHighestPriority(System.Collections.Generic.IEnumerable{Akka.Cluster.Member},System.Collections.Generic.IEnumerable{Akka.Cluster.Member})">
            <summary>
            TBD
            </summary>
            <param name="a">TBD</param>
            <param name="b">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Member.HighestPriorityOf(Akka.Cluster.Member,Akka.Cluster.Member)">
            <summary>
            Picks the Member with the highest "priority" MemberStatus.
            </summary>
            <param name="m1">TBD</param>
            <param name="m2">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="F:Akka.Cluster.Member.AllowedTransitions">
            <summary>
            All of the legal state transitions for a cluster member
            </summary>
        </member>
        <member name="T:Akka.Cluster.MemberStatus">
            <summary>
            Defines the current status of a cluster member node
            
            Can be one of: Joining, Up, Leaving, Exiting and Down.
            </summary>
        </member>
        <member name="F:Akka.Cluster.MemberStatus.Joining">
            <summary>
            Indicates that a new node is joining the cluster.
            </summary>
        </member>
        <member name="F:Akka.Cluster.MemberStatus.Up">
            <summary>
            Indicates that a node is a current member of the cluster.
            </summary>
        </member>
        <member name="F:Akka.Cluster.MemberStatus.Leaving">
            <summary>
            Indicates that a node is beginning to leave the cluster.
            </summary>
        </member>
        <member name="F:Akka.Cluster.MemberStatus.Exiting">
            <summary>
            Indicates that all nodes are aware that this node is leaving the cluster.
            </summary>
        </member>
        <member name="F:Akka.Cluster.MemberStatus.Down">
            <summary>
            Node was forcefully removed from the cluster by means of <see cref="M:Akka.Cluster.Cluster.Down(Akka.Actor.Address)"/>
            </summary>
        </member>
        <member name="F:Akka.Cluster.MemberStatus.Removed">
            <summary>
            Node was removed as a member from the cluster.
            </summary>
        </member>
        <member name="T:Akka.Cluster.UniqueAddress">
            <summary>
            Member identifier consisting of address and random `uid`.
            The `uid` is needed to be able to distinguish different
            incarnations of a member with same hostname and port.
            </summary>
        </member>
        <member name="P:Akka.Cluster.UniqueAddress.Address">
            <summary>
            The bound listening address for Akka.Remote.
            </summary>
        </member>
        <member name="P:Akka.Cluster.UniqueAddress.Uid">
            <summary>
            A random long integer used to signal the incarnation of this cluster instance.
            </summary>
        </member>
        <member name="M:Akka.Cluster.UniqueAddress.#ctor(Akka.Actor.Address,System.Int32)">
            <summary>
            Creates a new unique address instance.
            </summary>
            <param name="address">The original Akka <see cref="P:Akka.Cluster.UniqueAddress.Address"/></param>
            <param name="uid">The UID for the cluster instance.</param>
        </member>
        <member name="M:Akka.Cluster.UniqueAddress.Equals(Akka.Cluster.UniqueAddress)">
            <summary>
            Compares two unique address instances to each other.
            </summary>
            <param name="other">The other address to compare to.</param>
            <returns><c>true</c> if equal, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Cluster.UniqueAddress.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Akka.Cluster.UniqueAddress.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Akka.Cluster.UniqueAddress.CompareTo(Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="that">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.UniqueAddress.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Akka.Cluster.UniqueAddress.op_Equality(Akka.Cluster.UniqueAddress,Akka.Cluster.UniqueAddress)">
            <summary>
            Compares two specified unique addresses for equality.
            </summary>
            <param name="left">The first unique address used for comparison</param>
            <param name="right">The second unique address used for comparison</param>
            <returns><c>true</c> if both unique addresses are equal; otherwise <c>false</c></returns>
        </member>
        <member name="M:Akka.Cluster.UniqueAddress.op_Inequality(Akka.Cluster.UniqueAddress,Akka.Cluster.UniqueAddress)">
            <summary>
            Compares two specified unique addresses for inequality.
            </summary>
            <param name="left">The first unique address used for comparison</param>
            <param name="right">The second unique address used for comparison</param>
            <returns><c>true</c> if both unique addresses are not equal; otherwise <c>false</c></returns>
        </member>
        <member name="T:Akka.Cluster.Proto.ClusterMessageSerializer">
            <summary>
            Protobuff serializer for cluster messages
            </summary>
        </member>
        <member name="P:Akka.Cluster.Proto.ClusterMessageSerializer.Identifier">
            <summary>
            Completely unique value to identify this implementation of Serializer, used to optimize network traffic
            Values from 0 to 16 is reserved for Akka internal usage
            </summary>
        </member>
        <member name="P:Akka.Cluster.Proto.ClusterMessageSerializer.IncludeManifest">
            <summary>
            Returns whether this serializer needs a manifest in the fromBinary method
            </summary>
        </member>
        <member name="M:Akka.Cluster.Proto.ClusterMessageSerializer.ToBinary(System.Object)">
            <summary>
            Serializes the given object into a byte array
            </summary>
            <param name="obj">The object to serialize</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the specified object is not a cluster message.
            </exception>
            <returns>A byte array containing the serialized object</returns>
        </member>
        <member name="M:Akka.Cluster.Proto.ClusterMessageSerializer.FromBinary(System.Byte[],System.Type)">
            <summary>
            Deserializes a byte array into an object of type <paramref name="type" />.
            </summary>
            <param name="bytes">The array containing the serialized object</param>
            <param name="type">The type of object contained in the array</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the specified type is not a cluster message.
            </exception>
            <returns>The object contained in the array</returns>
        </member>
        <member name="M:Akka.Cluster.Proto.ClusterMessageSerializer.Compress(Google.ProtocolBuffers.IMessageLite)">
            <summary>
            Compresses the protobuf message using GZIP compression
            </summary>
            <param name="message">The message to compress</param>
            <returns>A byte array containing the compressed message</returns>
        </member>
        <member name="M:Akka.Cluster.Proto.ClusterMessageSerializer.Decompress(System.Byte[])">
            <summary>
            Decompresses the protobuf message using GZIP compression
            </summary>
            <param name="bytes">The array containing the message to decompress</param>
            <returns>A byte array containing the decompressed message</returns>
        </member>
        <member name="T:Akka.Cluster.Reachability">
             <summary>
             Immutable data structure that holds the reachability status of subject nodes as seen
             from observer nodes. Failure detector for the subject nodes exist on the
             observer nodes. Changes (reachable, unreachable, terminated) are only performed
             by observer nodes to its own records. Each change bumps the version number of the
             record, and thereby it is always possible to determine which record is newest 
             merging two instances.
            
             Aggregated status of a subject node is defined as (in this order):
             - Terminated if any observer node considers it as Terminated
             - Unreachable if any observer node considers it as Unreachable
             - Reachable otherwise, i.e. no observer node considers it as Unreachable
             </summary>
        </member>
        <member name="F:Akka.Cluster.Reachability.Empty">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.Reachability.#ctor(System.Collections.Immutable.ImmutableList{Akka.Cluster.Reachability.Record},System.Collections.Immutable.ImmutableDictionary{Akka.Cluster.UniqueAddress,System.Int64})">
            <summary>
            TBD
            </summary>
            <param name="records">TBD</param>
            <param name="versions">TBD</param>
        </member>
        <member name="T:Akka.Cluster.Reachability.Record">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.Reachability.Record.Observer">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.Reachability.Record.Subject">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.Reachability.Record.Status">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.Reachability.Record.Version">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.Reachability.Record.#ctor(Akka.Cluster.UniqueAddress,Akka.Cluster.UniqueAddress,Akka.Cluster.Reachability.ReachabilityStatus,System.Int64)">
            <summary>
            TBD
            </summary>
            <param name="observer">TBD</param>
            <param name="subject">TBD</param>
            <param name="status">TBD</param>
            <param name="version">TBD</param>
        </member>
        <member name="M:Akka.Cluster.Reachability.Record.Equals(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Reachability.Record.GetHashCode">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.Reachability.ReachabilityStatus">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Cluster.Reachability.ReachabilityStatus.Reachable">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Cluster.Reachability.ReachabilityStatus.Unreachable">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Cluster.Reachability.ReachabilityStatus.Terminated">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.Reachability.Records">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.Reachability.Versions">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Cluster.Reachability.Cache">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.Reachability.Cache.ObserverRowMap">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.Reachability.Cache.AllTerminated">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.Reachability.Cache.AllUnreachable">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.Reachability.Cache.AllUnreachableOrTerminated">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.Reachability.Cache.#ctor(System.Collections.Immutable.ImmutableList{Akka.Cluster.Reachability.Record})">
            <summary>
            TBD
            </summary>
            <param name="records">TBD</param>
        </member>
        <member name="M:Akka.Cluster.Reachability.Unreachable(Akka.Cluster.UniqueAddress,Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="observer">TBD</param>
            <param name="subject">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Reachability.Reachable(Akka.Cluster.UniqueAddress,Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="observer">TBD</param>
            <param name="subject">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Reachability.Terminated(Akka.Cluster.UniqueAddress,Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="observer">TBD</param>
            <param name="subject">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Reachability.Merge(System.Collections.Generic.IEnumerable{Akka.Cluster.UniqueAddress},Akka.Cluster.Reachability)">
            <summary>
            TBD
            </summary>
            <param name="allowed">TBD</param>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Reachability.Remove(System.Collections.Generic.IEnumerable{Akka.Cluster.UniqueAddress})">
            <summary>
            TBD
            </summary>
            <param name="nodes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Reachability.RemoveObservers(System.Collections.Immutable.ImmutableHashSet{Akka.Cluster.UniqueAddress})">
            <summary>
            TBD
            </summary>
            <param name="nodes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Reachability.Status(Akka.Cluster.UniqueAddress,Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="observer">TBD</param>
            <param name="subject">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Reachability.Status(Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="node">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Reachability.IsReachable(Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="node">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Reachability.IsReachable(Akka.Cluster.UniqueAddress,Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="observer">TBD</param>
            <param name="subject">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Cluster.Reachability.IsAllReachable">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.Reachability.AllUnreachable">
            <summary>
            Doesn't include terminated
            </summary>
        </member>
        <member name="P:Akka.Cluster.Reachability.AllUnreachableOrTerminated">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.Reachability.AllUnreachableFrom(Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="observer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Cluster.Reachability.ObserversGroupedByUnreachable">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.Reachability.AllObservers">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.Reachability.RecordsFrom(Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="observer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Reachability.GetHashCode">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Reachability.Equals(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Reachability.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.Routing.ClusterRouterGroupSettings">
            <summary>
            <see cref="P:Akka.Cluster.Routing.ClusterRouterSettingsBase.TotalInstances"/> of cluster router must be > 0
            </summary>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterGroupSettings.#ctor(System.Int32,System.Boolean,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Obsolete. This constructor is no longer applicable.
            </summary>
            <param name="totalInstances">N/A</param>
            <param name="allowLocalRoutees">N/A</param>
            <param name="routeesPaths">N/A</param>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterGroupSettings.#ctor(System.Int32,System.Boolean,System.String,System.Collections.Immutable.ImmutableHashSet{System.String})">
            <summary>
            Obsolete. This constructor is no longer applicable.
            </summary>
            <param name="totalInstances">N/A</param>
            <param name="allowLocalRoutees">N/A</param>
            <param name="useRole">N/A</param>
            <param name="routeesPaths">N/A</param>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterGroupSettings.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Cluster.Routing.ClusterRouterGroupSettings"/> class.
            </summary>
            <param name="totalInstances">TBD</param>
            <param name="routeesPaths">TBD</param>
            <param name="allowLocalRoutees">TBD</param>
            <param name="useRole">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when either the specified <paramref name="routeesPaths"/> is undefined
            or a path defined in the specified <paramref name="routeesPaths"/> is an invalid relative actor path.
            </exception>
        </member>
        <member name="P:Akka.Cluster.Routing.ClusterRouterGroupSettings.RouteesPaths">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterGroupSettings.FromConfig(Akka.Configuration.Config)">
            <summary>
            Creates a new <see cref="T:Akka.Cluster.Routing.ClusterRouterGroupSettings"/> from the specified configuration.
            </summary>
            <param name="config">The configuration used to configure the settings.</param>
            <returns>New settings based on the specified <paramref name="config"/></returns>
        </member>
        <member name="T:Akka.Cluster.Routing.ClusterRouterPoolSettings">
            <summary>
            <see cref="P:Akka.Cluster.Routing.ClusterRouterSettingsBase.TotalInstances"/> of cluster router must be > 0
            <see cref="P:Akka.Cluster.Routing.ClusterRouterPoolSettings.MaxInstancesPerNode"/> of cluster router must be > 0
            <see cref="P:Akka.Cluster.Routing.ClusterRouterPoolSettings.MaxInstancesPerNode"/> of cluster router must be 1 when routeesPath is defined
            </summary>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterPoolSettings.#ctor(System.Int32,System.Boolean,System.Int32)">
            <summary>
            Obsolete. This constructor is no longer applicable.
            </summary>
            <param name="totalInstances">N/A</param>
            <param name="allowLocalRoutees">N/A</param>
            <param name="maxInstancesPerNode">N/A</param>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterPoolSettings.#ctor(System.Int32,System.Boolean,System.String,System.Int32)">
            <summary>
            Obsolete. This constructor is no longer applicable.
            </summary>
            <param name="totalInstances">N/A</param>
            <param name="allowLocalRoutees">N/A</param>
            <param name="useRole">N/A</param>
            <param name="maxInstancesPerNode">N/A</param>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterPoolSettings.#ctor(System.Int32,System.Int32,System.Boolean,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Cluster.Routing.ClusterRouterPoolSettings"/> class.
            </summary>
            <param name="totalInstances">TBD</param>
            <param name="maxInstancesPerNode">TBD</param>
            <param name="allowLocalRoutees">TBD</param>
            <param name="useRole">TBD</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            This exception is thrown when the specified <paramref name="maxInstancesPerNode"/> is less than or equal to zero.
            </exception>
        </member>
        <member name="P:Akka.Cluster.Routing.ClusterRouterPoolSettings.MaxInstancesPerNode">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterPoolSettings.FromConfig(Akka.Configuration.Config)">
            <summary>
            Creates a new <see cref="T:Akka.Cluster.Routing.ClusterRouterPoolSettings"/> from the specified configuration.
            </summary>
            <param name="config">The configuration used to configure the settings.</param>
            <returns>New settings based on the specified <paramref name="config"/></returns>
        </member>
        <member name="T:Akka.Cluster.Routing.ClusterRouterSettingsBase">
            <summary>
            Base class for defining <see cref="T:Akka.Cluster.Routing.ClusterRouterGroupSettings"/> and <see cref="T:Akka.Cluster.Routing.ClusterRouterPoolSettings"/>
            </summary>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterSettingsBase.#ctor(System.Int32,System.Boolean,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Cluster.Routing.ClusterRouterSettingsBase"/> class.
            </summary>
            <param name="totalInstances">TBD</param>
            <param name="allowLocalRoutees">TBD</param>
            <param name="useRole">TBD</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            This exception is thrown when the specified <paramref name="useRole"/> is undefined
            or the specified <paramref name="totalInstances"/> is less than or equal to zero.
            </exception>
        </member>
        <member name="P:Akka.Cluster.Routing.ClusterRouterSettingsBase.TotalInstances">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.Routing.ClusterRouterSettingsBase.AllowLocalRoutees">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.Routing.ClusterRouterSettingsBase.UseRole">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterSettingsBase.UseRoleOption(System.String)">
            <summary>
            TBD
            </summary>
            <param name="role">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterSettingsBase.GetMaxTotalNrOfInstances(Akka.Configuration.Config)">
            <summary>
            TBD
            </summary>
            <param name="config">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.Routing.ClusterRouterPool">
            <summary>
            <see cref="T:Akka.Routing.RouterConfig"/> implementation for deployment on cluster nodes.
            Delegates other duties to the local <see cref="T:Akka.Routing.RouterConfig"/>, which makes it
            possible to mix this with built-in routers such as <see cref="T:Akka.Routing.RoundRobinGroup"/> or
            custom routers.
            </summary>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterPool.#ctor(Akka.Routing.Pool,Akka.Cluster.Routing.ClusterRouterPoolSettings)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Cluster.Routing.ClusterRouterPool"/> class.
            </summary>
            <param name="local">TBD</param>
            <param name="settings">TBD</param>
            <exception cref="T:Akka.Configuration.ConfigurationException">
            This exception is thrown when the resizer in the specified pool <paramref name="local"/> is defined.
            A resizer cannot be used in conjunction with a cluster router.
            </exception>
        </member>
        <member name="P:Akka.Cluster.Routing.ClusterRouterPool.Settings">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.Routing.ClusterRouterPool.Local">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterPool.NewRoutee(Akka.Actor.Props,Akka.Actor.IActorContext)">
            <summary>
            TBD
            </summary>
            <param name="routeeProps">TBD</param>
            <param name="context">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterPool.GetNrOfInstances(Akka.Actor.ActorSystem)">
            <summary>
            Returns the initial number of routees
            </summary>
            <param name="system">The actor system to which this router belongs.</param>
            <returns>The initial number of routees</returns>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterPool.CreateRouterActor">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Cluster.Routing.ClusterRouterPool.SupervisorStrategy">
            <summary>
            Retrieve the strategy to use when supervising the pool.
            </summary>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterPool.WithFallback(Akka.Routing.RouterConfig)">
            <summary>
            Configure the current router with an auxiliary router for routes that it does not know how to handle.
            </summary>
            <param name="routerConfig">The router to use as an auxiliary source.</param>
            <exception cref="T:Akka.Configuration.ConfigurationException">
            This exception is thrown when the specified router is another <see cref="T:Akka.Cluster.Routing.ClusterRouterPool"/>.
            This configuration is not allowed.
            </exception>
            <returns>The router configured with the auxiliary information.</returns>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterPool.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
            </summary>
            <param name="system">The ActorSystem this router belongs to.</param>
            <returns>The newly created router tied to the given system.</returns>
        </member>
        <member name="P:Akka.Cluster.Routing.ClusterRouterPool.RouterDispatcher">
            <summary>
            Dispatcher ID to use for running the head actor, which handles supervision, death watch and router management messages.
            </summary>
        </member>
        <member name="P:Akka.Cluster.Routing.ClusterRouterPool.StopRouterWhenAllRouteesRemoved">
            <summary>
            Specify that this router should stop itself when all routees have terminated (been removed).
            </summary>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterPool.RoutingLogicController(Akka.Routing.RoutingLogic)">
            <summary>
            TBD
            </summary>
            <param name="routingLogic">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterPool.IsManagementMessage(System.Object)">
            <summary>
            Determines whether a provided message is handled by the router.
            </summary>
            <param name="message">The message to inspect.</param>
            <returns><c>true</c> if this message is handled by the router; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterPool.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            N/A
            </summary>
            <param name="system">N/A</param>
            <exception cref="T:System.NotImplementedException">
            This exception is thrown automatically since surrogates aren't supported by this router.
            </exception>
            <returns>N/A</returns>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterPool.Copy(Akka.Routing.Pool,Akka.Cluster.Routing.ClusterRouterPoolSettings)">
            <summary>
            TBD
            </summary>
            <param name="local">TBD</param>
            <param name="settings">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.Routing.ClusterRouterGroup">
            <summary>
            <see cref="T:Akka.Routing.RouterConfig"/> implementation for deployment on cluster nodes.
            Delegates other duties to the local <see cref="T:Akka.Routing.RouterConfig"/>, which makes it
            possible to mix this with built-in routers such as <see cref="T:Akka.Routing.RoundRobinGroup"/> or
            custom routers.
            </summary>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterGroup.#ctor(Akka.Routing.Group,Akka.Cluster.Routing.ClusterRouterGroupSettings)">
            <summary>
            TBD
            </summary>
            <param name="local">TBD</param>
            <param name="settings">TBD</param>
        </member>
        <member name="P:Akka.Cluster.Routing.ClusterRouterGroup.Settings">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.Routing.ClusterRouterGroup.Local">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterGroup.GetPaths(Akka.Actor.ActorSystem)">
            <summary>
            Retrieves the actor paths used by this router during routee selection.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>An enumeration of actor paths used during routee selection</returns>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterGroup.CreateRouterActor">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterGroup.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
            </summary>
            <param name="system">The ActorSystem this router belongs to.</param>
            <returns>The newly created router tied to the given system.</returns>
        </member>
        <member name="P:Akka.Cluster.Routing.ClusterRouterGroup.RouterDispatcher">
            <summary>
            Dispatcher ID to use for running the head actor, which handles supervision, death watch and router management messages.
            </summary>
        </member>
        <member name="P:Akka.Cluster.Routing.ClusterRouterGroup.StopRouterWhenAllRouteesRemoved">
            <summary>
            Specify that this router should stop itself when all routees have terminated (been removed).
            By Default it is `true`, unless a `resizer` is used.
            </summary>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterGroup.RoutingLogicController(Akka.Routing.RoutingLogic)">
            <summary>
            TBD
            </summary>
            <param name="routingLogic">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterGroup.IsManagementMessage(System.Object)">
            <summary>
            Determines whether a provided message is handled by the router.
            </summary>
            <param name="message">The message to inspect.</param>
            <returns><c>true</c> if this message is handled by the router; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterGroup.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current router.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current router.</returns>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterGroup.WithFallback(Akka.Routing.RouterConfig)">
            <summary>
            Configure the current router with an auxiliary router for routes that it does not know how to handle.
            </summary>
            <param name="routerConfig">The router to use as an auxiliary source.</param>
            <exception cref="T:Akka.Configuration.ConfigurationException">
            This exception is thrown when the specified router is another <see cref="T:Akka.Cluster.Routing.ClusterRouterGroup"/>.
            This configuration is not allowed.
            </exception>
            <returns>The router configured with the auxiliary information.</returns>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterGroup.Copy(Akka.Routing.Group,Akka.Cluster.Routing.ClusterRouterGroupSettings)">
            <summary>
            TBD
            </summary>
            <param name="local">TBD</param>
            <param name="settings">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.Routing.ClusterRouterActor">
            <summary>
            INTERNAL API
            The router actor, subscribes to cluster events and
            adjusts the routees.
            </summary>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterActor.#ctor(Akka.Cluster.Routing.ClusterRouterSettingsBase)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Cluster.Routing.ClusterRouterActor"/> class.
            </summary>
            <param name="settings">The settings used to configure the router.</param>
            <exception cref="T:Akka.Actor.ActorInitializationException">
            This exception is thrown when this actor is configured as something other than a <see cref="T:Akka.Routing.Pool"/> router or <see cref="T:Akka.Routing.Group"/> router.
            </exception>
        </member>
        <member name="P:Akka.Cluster.Routing.ClusterRouterActor.Settings">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.Routing.ClusterRouterActor.Cluster">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterActor.PreStart">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterActor.PostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.Routing.ClusterRouterActor.Nodes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterActor.IsAvailable(Akka.Cluster.Member)">
            <summary>
            TBD
            </summary>
            <param name="member">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Cluster.Routing.ClusterRouterActor.AvailableNodes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterActor.FullAddress(Akka.Routing.Routee)">
            <summary>
            Fills in self address for local <see cref="T:Akka.Actor.IActorRef"/>
            </summary>
            <param name="routee">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterActor.AddRoutees">
            <summary>
            Adds routees based on settings
            </summary>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterActor.AddMember(Akka.Cluster.Member)">
            <summary>
            TBD
            </summary>
            <param name="member">TBD</param>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterActor.RemoveMember(Akka.Cluster.Member)">
            <summary>
            TBD
            </summary>
            <param name="member">TBD</param>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterActor.OnReceive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
        </member>
        <member name="T:Akka.Cluster.Routing.ClusterRouterGroupActor">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterGroupActor.#ctor(Akka.Cluster.Routing.ClusterRouterGroupSettings)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Cluster.Routing.ClusterRouterGroupActor"/> class.
            </summary>
            <param name="settings">The settings used to configure the router.</param>
            <exception cref="T:Akka.Actor.ActorInitializationException">
            This exception is thrown when this actor is configured as something other than a <see cref="T:Akka.Routing.Group"/> router.
            </exception>
        </member>
        <member name="P:Akka.Cluster.Routing.ClusterRouterGroupActor.Settings">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.Routing.ClusterRouterGroupActor.UsedRouteePaths">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterGroupActor.AddRoutees">
            <summary>
            Adds routees based on totalInstances and maxInstancesPerNode settings
            </summary>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterGroupActor.SelectDeploymentTarget">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterGroupActor.RemoveMember(Akka.Cluster.Member)">
            <summary>
            TBD
            </summary>
            <param name="member">TBD</param>
        </member>
        <member name="T:Akka.Cluster.Routing.ClusterRouterPoolActor">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="F:Akka.Cluster.Routing.ClusterRouterPoolActor.Pool">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterPoolActor.#ctor(Akka.Actor.SupervisorStrategy,Akka.Cluster.Routing.ClusterRouterPoolSettings)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Cluster.Routing.ClusterRouterPoolActor"/> class.
            </summary>
            <param name="supervisorStrategy">The strategy used to supervise the pool.</param>
            <param name="settings">The settings used to configure the router.</param>
            <exception cref="T:Akka.Actor.ActorInitializationException">
            This exception is thrown when this actor is configured as something other than a <see cref="T:Akka.Routing.Pool"/> router.
            </exception>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterPoolActor.SupervisorStrategy">
            <summary>
            Retrieve the strategy used when supervising the pool.
            </summary>
            <returns>The strategy used when supervising the pool</returns>
        </member>
        <member name="P:Akka.Cluster.Routing.ClusterRouterPoolActor.Settings">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterPoolActor.AddRoutees">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterPoolActor.SelectDeploymentTarget">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Routing.ClusterRouterPoolActor.OnReceive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
        </member>
        <member name="T:Akka.Cluster.Utils">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.Utils.Min``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="source">TBD</param>
            <param name="comparer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Utils.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            TBD
            </summary>
            <typeparam name="TSource">TBD</typeparam>
            <typeparam name="TKey">TBD</typeparam>
            <param name="source">TBD</param>
            <param name="selector">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Utils.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            TBD
            </summary>
            <typeparam name="TSource">TBD</typeparam>
            <typeparam name="TKey">TBD</typeparam>
            <param name="source">TBD</param>
            <param name="selector">TBD</param>
            <param name="comparer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Utils.GetTimeSpanWithOffSwitch(Akka.Configuration.Config,System.String)">
            <summary>
            TBD
            </summary>
            <param name="this">TBD</param>
            <param name="key">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.Utils.Partition``1(System.Collections.Immutable.ImmutableSortedSet{``0},System.Func{``0,System.Boolean})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="this">TBD</param>
            <param name="partitioner">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.VectorClock">
            <summary>
            <para>
            Representation of a Vector-based clock (counting clock), inspired by Lamport logical clocks.
            </para>
            <para>
            Reference:
            <ol>
            <li>Leslie Lamport (1978). "Time, clocks, and the ordering of events in a distributed system". Communications of the ACM 21 (7): 558-565.</li>
            <li>Friedemann Mattern (1988). "Virtual Time and Global States of Distributed Systems". Workshop on Parallel and Distributed Algorithms: pp. 215-226</li>
            </ol>
            </para>
            <para>
            Based on code from the 'vlock' VectorClock library by Coda Hale.
            </para>
            </summary>
        </member>
        <member name="T:Akka.Cluster.VectorClock.Node">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.VectorClock.Node.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="value">TBD</param>
        </member>
        <member name="M:Akka.Cluster.VectorClock.Node.Create(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.VectorClock.Node.FromHash(System.String)">
            <summary>
            TBD
            </summary>
            <param name="hash">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.VectorClock.Node.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.</returns>
        </member>
        <member name="M:Akka.Cluster.VectorClock.Node.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" />, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns><c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Cluster.VectorClock.Node.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>A <see cref="T:System.String" /> that represents this instance.</returns>
        </member>
        <member name="M:Akka.Cluster.VectorClock.Node.CompareTo(Akka.Cluster.VectorClock.Node)">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Cluster.VectorClock.Timestamp">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Cluster.VectorClock.Timestamp.Zero">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Cluster.VectorClock.Timestamp.EndMarker">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Cluster.VectorClock.Ordering">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Cluster.VectorClock.Ordering.After">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Cluster.VectorClock.Ordering.Before">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Cluster.VectorClock.Ordering.Same">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Cluster.VectorClock.Ordering.Concurrent">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Cluster.VectorClock.Ordering.FullOrder">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Cluster.VectorClock.Versions">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Cluster.VectorClock.Create">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.VectorClock.Create(System.Collections.Immutable.ImmutableSortedDictionary{Akka.Cluster.VectorClock.Node,System.Int64})">
            <summary>
            TBD
            </summary>
            <param name="seedValues">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.VectorClock.Increment(Akka.Cluster.VectorClock.Node)">
            <summary>
            Increment the version for the node passed as argument. Returns a new VectorClock.
            </summary>
            <param name="node">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.VectorClock.IsConcurrentWith(Akka.Cluster.VectorClock)">
            <summary>
            Returns true if <code>this</code> and <code>that</code> are concurrent else false.
            </summary>
            <param name="that">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.VectorClock.IsBefore(Akka.Cluster.VectorClock)">
            <summary>
            Returns true if <code>this</code> is before <code>that</code> else false.
            </summary>
            <param name="that">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.VectorClock.IsAfter(Akka.Cluster.VectorClock)">
            <summary>
            Returns true if <code>this</code> is after <code>that</code> else false.
            </summary>
            <param name="that">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.VectorClock.IsSameAs(Akka.Cluster.VectorClock)">
            <summary>
            Returns true if this VectorClock has the same history as the 'that' VectorClock else false.
            </summary>
            <param name="that">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.VectorClock.op_GreaterThan(Akka.Cluster.VectorClock,Akka.Cluster.VectorClock)">
            <summary>
            Compares two specified vector clocks to see if the first one is greater than the other one.
            </summary>
            <param name="left">The first vector clock used for comparison</param>
            <param name="right">The second vector clock used for comparison</param>
            <returns><c>true</c> if the first vector clock is greater than the other one; otherwise <c>false</c></returns>
        </member>
        <member name="M:Akka.Cluster.VectorClock.op_LessThan(Akka.Cluster.VectorClock,Akka.Cluster.VectorClock)">
            <summary>
            Compares two specified vector clocks to see if the first one is less than the other one.
            </summary>
            <param name="left">The first vector clock used for comparison</param>
            <param name="right">The second vector clock used for comparison</param>
            <returns><c>true</c> if the first vector clock is less than the other one; otherwise <c>false</c></returns>
        </member>
        <member name="M:Akka.Cluster.VectorClock.op_Equality(Akka.Cluster.VectorClock,Akka.Cluster.VectorClock)">
            <summary>
            Compares two specified vector clocks for equality.
            </summary>
            <param name="left">The first vector clock used for comparison</param>
            <param name="right">The second vector clock used for comparison</param>
            <returns><c>true</c> if both vector clocks are equal; otherwise <c>false</c></returns>
        </member>
        <member name="M:Akka.Cluster.VectorClock.op_Inequality(Akka.Cluster.VectorClock,Akka.Cluster.VectorClock)">
            <summary>
            Compares two specified vector clocks for inequality.
            </summary>
            <param name="left">The first vector clock used for comparison</param>
            <param name="right">The second vector clock used for comparison</param>
            <returns><c>true</c> if both vector clocks are not equal; otherwise <c>false</c></returns>
        </member>
        <member name="M:Akka.Cluster.VectorClock.CompareOnlyTo(Akka.Cluster.VectorClock,Akka.Cluster.VectorClock.Ordering)">
            <summary>
            <para>
            Vector clock comparison according to the semantics described by compareTo,
            with the ability to bail out early if the we can't reach the <see cref="T:Akka.Cluster.VectorClock.Ordering"/>
            that we are looking for.
            </para>
            <para>
            The ordering always starts with <see cref="F:Akka.Cluster.VectorClock.Ordering.Same"/> and can then go to
            <see cref="F:Akka.Cluster.VectorClock.Ordering.Same"/>, <see cref="F:Akka.Cluster.VectorClock.Ordering.Before"/> or <see cref="F:Akka.Cluster.VectorClock.Ordering.After"/>.
            </para>
            <para>
            <ul>
            <li>If we're on <see cref="F:Akka.Cluster.VectorClock.Ordering.After"/>, then we can only go to <see cref="F:Akka.Cluster.VectorClock.Ordering.After"/> or <see cref="F:Akka.Cluster.VectorClock.Ordering.Concurrent"/>.</li>
            <li>If we're on <see cref="F:Akka.Cluster.VectorClock.Ordering.Before"/>, then we can only go to <see cref="F:Akka.Cluster.VectorClock.Ordering.Before"/>Before or <see cref="F:Akka.Cluster.VectorClock.Ordering.Concurrent"/>.</li>
            <li>If we go to <see cref="F:Akka.Cluster.VectorClock.Ordering.Concurrent"/>, then we exit the loop immediately></li>
            <li>If you send in the ordering <see cref="F:Akka.Cluster.VectorClock.Ordering.FullOrder"/>FullOrder, then you will get a full comparison.</li>
            </ul>
            </para>
            </summary>
            <param name="that">TBD</param>
            <param name="order">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.VectorClock.CompareTo(Akka.Cluster.VectorClock)">
            <summary>
            <para>
            Compares the current vector clock with the supplied vector clock. The outcome will be one of the following:
            </para>
            <ol>
            <li><![CDATA[ Clock 1 is SAME(==)       as Clock 2 iff for all i c1(i) == c2(i) ]]></li>
            <li><![CDATA[ Clock 1 is BEFORE(<)      Clock 2 iff for all i c1(i) <= c2(i) and there exist a j such that c1(j) < c2(j) ]]></li>
            <li><![CDATA[ Clock 1 is AFTER(>)       Clock 2 iff for all i c1(i) >= c2(i) and there exist a j such that c1(j) > c2(j). ]]></li>
            <li><![CDATA[ Clock 1 is CONCURRENT(<>) to Clock 2 otherwise. ]]></li>
            </ol>
            </summary>
            <param name="that">The vector clock used to compare against.</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Cluster.VectorClock.Merge(Akka.Cluster.VectorClock)">
            <summary>
            Merges the vector clock with another <see cref="T:Akka.Cluster.VectorClock"/> (e.g. merges its versioned history).
            </summary>
            <param name="that">The vector clock to merge into the current clock.</param>
            <returns>A newly created <see cref="T:Akka.Cluster.VectorClock"/> with the current vector clock and the given vector clock merged.</returns>
        </member>
        <member name="M:Akka.Cluster.VectorClock.Prune(Akka.Cluster.VectorClock.Node)">
            <summary>
            Removes the specified node from the current vector clock.
            </summary>
            <param name="removedNode">The node that is being removed.</param>
            <returns>A newly created <see cref="T:Akka.Cluster.VectorClock"/> that has the given node removed.</returns>
        </member>
        <member name="M:Akka.Cluster.VectorClock.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>A <see cref="T:System.String" /> that represents this instance.</returns>
        </member>
    </members>
</doc>
